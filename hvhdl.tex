\section{A target language: \hvhdl{}}
\label{sec:hvhdl}

The \hilecop{} model-to-text transformation generates a \vhdl{} design
out of an input SITPN model. Therefore, to conduct to proof of
semantic preservation, the syntax and semantics of the \vhdl{}
language must be formally set. The designs generated by the \hilecop{}
transformation rely on subset of the \vhdl{} that we identify as
\hvhdl{} and present in the following abstract syntax.

\subsection{The abstract syntax of \hvhdl{}}
\label{subsec:abs-syntax}

The following subset of \vhdl{} has been determined based on
\hilecop{}'s transformation, and also on the definition of two
pre-defined designs, i.e. the place and transition designs. As it will
be presented in Section~\ref{sec:m2t}, the \hilecop{} transformation
is mainly about instantiating, i.e. creating an instance of a design
acting as a subcomponent in the behavior of an embedding design, the
place and transition designs. Thus, being able to reason about the
\hilecop{}'s generated \vhdl{} designs is being able to reason about
the code of the place and transition designs. This is why the abstract
syntax of \hvhdl{} is closely tied to the content of the place and
transition designs.  We present the syntax of \hvhdl{} in a bottom-up
manner, starting from expressions to higher constructs.

\begin{table}[!htbp]
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $e$ & ::= $name$ & read a signal, a local variable \\
    & & or a generic constant value \\
    & \quad $\vert{}~cst$ & constant \\
    & \quad $\vert{}~bop$($e_1$, $e_2$) & binary operation \\
    & \quad $\vert{}~uop$($e$) & unary operation \\
    & \quad $\vert{}~$\texttt{(}$e^{+}$\texttt{)} & aggregate expression \\
    & & \\
    $name$ & ::= $id$ & read a signal, local variable, \\
    & & or generic constant value \\
    & \quad$\vert{}~$ $id$\texttt{(}$e$\texttt{)} & read value of an array signal  \\
    & & or local variable at index $e$ \\
    & & \\
    $cst$ & ::= $n$ $\vert{}~$ $b$ & natural or Boolean \\
    & & \\
    $bop$ & ::= \texttt{and} $\vert{}$ \texttt{or} & Boolean operators \\
    & \quad$\vert{}$ \texttt{add} $\vert{}$ \texttt{sub} & natural number arithmetic \\
    & \quad$\vert{}$ \texttt{eq} $\vert{}$ \texttt{ne} $\vert{}$ \texttt{gt} $\vert{}$ \texttt{ge} $\vert{}$ \texttt{lt} $\vert{}$ \texttt{le} & comparisons \\
    & & \\
    $uop$ & ::= \texttt{not} & Boolean negation \\
    & & \\
    \hline
  \end{tabular}
  \caption{Expressions}
  \label{tab:expr}
\end{table}

The expressions of \hvhdl{} are restrained to operations over Boolean
or natural numbers that are used in the designs generated by the
transformation, and more particularly the ones used in the pre-defined
place and transition designs.

\begin{table}[!htbp]
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $ss$ & ::= $name~\mathtt{\Leftarrow}~e$ & assignment to a signal \\
    & \quad$\vert{}~name~\mathtt{:=}~e$ & assignment to a local variable \\
    & \quad$\vert{}~\mathtt{if}(e)\{ss_1\}~\mathtt{else}~\{ss_2\}$ & conditional \\
    & \quad$\vert{}~\mathtt{for}(id,e_1,e_2)\{ss\}$ & range loop \\
    & \quad$\vert{}~\mathtt{falling}\{ss\}$ & falling edge block \\
    & \quad$\vert{}~\mathtt{rising}\{ss\}$ & rising edge block \\
    & \quad$\vert{}~\mathtt{rst}~\{ss_1\}~\mathtt{else}~\{ss_2\}$ & reset conditional \\
    & \quad$\vert{}~ss_1\mathtt{;}ss_2$ & sequence \\
    & \quad$\vert{}~\mathtt{null}$ & no operation \\
    & & \\
    \hline
  \end{tabular}
  \caption{Sequential statements}
  \label{tab:ss}
\end{table}

Sequential statements are used to defined the body of processes, and
mainly act upon the value of signals and local variables through
assignment operations. The set of sequential statement includes the
classical conditional, range loop, and sequence statements. We add
particular statements, namely the falling edge, rising edge and reset
conditional statements, derived from the concrete syntax of \vhdl{}.
These statements are convenient to express block of statements to be
executed only at certain phases of the simulation.


\begin{table}[!htbp]
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $\tau$ & ::= \texttt{bool} & boolean \\
    & \quad$\vert{}~$ \texttt{nat} \texttt{(}$e_1$\texttt{,} $e_2$\texttt{)} & natural range $e_1$ to $e_2$ \\
    & \quad$\vert{}~$ \texttt{array} \texttt{(}$\tau$\texttt{,} $e_1$\texttt{,} $e_2$\texttt{)} & array of $\tau$ with index range $e_1$ to $e_2$ \\
    & & \\
    \hline
  \end{tabular}
  \caption{Type indication}
  \label{tab:typeind}
\end{table}

A type indication informs us about the type of a given signal, local
variable, or generic constant at the time of its declaration. A
signal, a local variable or a generic constant can be a Boolean, a
natural number defined in a certain range, or an array of elements
associated with a certain type indication.

\begin{table}[!htbp]
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $cs$ & ::= $ps$ & process statement \\
    & $\vert{}~$ $comp$ & design instantiation statement \\
    & $\vert{}~$ $cs_1~\mathtt{||}~cs_2$ & parallel composition \\
    & $\vert{}~$ \texttt{null} & no operation \\
    & & \\
    $ps$ & ::= $\mathtt{ps}(id_p,$ & process identifier \\
    & \quad\quad\quad${}vars=\{(id,\tau)^{*}\},$ & local variable declarations\\
    & \quad\quad\quad${}body=ss)$ & statement body \\
    & & \\
    $comp$ & ::= $\mathtt{comp}(id_c,$ & component instance identifier \\
      & \quad\quad\quad\quad$id_e,$ & instantiated design identifier \\
      & \quad\quad\quad\quad${}g=\{(id\Rightarrow{}e)^{*}\},$ & generic constant map \\
      & \quad\quad\quad\quad${}i=\{(name\Rightarrow{}e)^{*}\},$ & input port map \\
    & \quad\quad\quad\quad$o=\{\big((id\Rightarrow{}(name\vert{}\mathtt{open}))$ & output port map \\
    & \quad\quad\quad\quad\quad\quad\quad$\vert{}(id(e)\Rightarrow{}name)\big)^{*}\})$ &  \\
    & & \\
    \hline
  \end{tabular}
  \caption{Concurrent statements}
  \label{tab:cs}
\end{table}

The behavior of a design is defined by concurrent statements. A
concurrent statement can be a process, a design instantiation, or the
parallel composition of two concurrent statements. A process statement
declares a set of local variables, and executes operations over
signals and variables defined in its sequential statement body. A
design instantiation statement represents the creation of a
subcomponent having a part in the definition of the embedding
design. A design instantiation statement indicates which design is
instantiated as a subcomponent (i.e. $id_e$). It also indicates how
the subcomponent is dimensioned through a generic constant map
(i.e. $g$). Moreover, it indicates how the subcomponent is connected
to the other parts of the embedding design through a input port
(i.e. $i$) and output port map (i.e. $o$).

\begin{table}[!htbp]
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $design$ & ::= $\{{}gens=\{(id,\tau,e)^{*}\},$ & generic constants \\
    & \quad\quad${}ports=\{((\mathtt{in}\vert\mathtt{out}),id,\tau)^{*}\},$ & input and output ports \\
    & \quad\quad${}sigs=\{(id,\tau)^{*}\},$ & internal signals \\
    & \quad\quad${}behavior=cs\}$ & design behavior \\
    & & \\
    \hline
  \end{tabular}
  \caption{Design}
  \label{tab:design}
\end{table}

The highest construct of the \hvhdl{} language is the design. A design
represents a whole circuit by itself. Once defined, a design can be
later be instantiated to define the behavior of other designs. A
design that is not instantiated as a part of the behavior of another
design is referred to as a \textit{top-level} design.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
