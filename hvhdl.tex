\section{A target language: \hvhdl{}}
\label{sec:hvhdl}

The \hilecop{} model-to-text transformation generates a \vhdl{} design
out of an input SITPN model. Therefore, to conduct to proof of
semantic preservation, the syntax and semantics of the \vhdl{}
language must be formally set. The designs generated by the \hilecop{}
transformation rely on subset of the \vhdl{} that we identify as
\hvhdl{} and present in the following abstract syntax.

\subsection{The abstract syntax of \hvhdl{}}
\label{subsec:abs-syntax}

The following subset of \vhdl{} has been determined based on
\hilecop{}'s transformation, and also on the definition of two
pre-defined designs, i.e. the place and transition designs. As it will
be presented in Section~\ref{sec:m2t}, the \hilecop{} transformation
is mainly about instantiating, i.e. creating an instance of a design
acting as a subcomponent in the behavior of an embedding design, the
place and transition designs. Thus, being able to reason about the
\hilecop{}'s generated \vhdl{} designs is being able to reason about
the code of the place and transition designs. This is why the abstract
syntax of \hvhdl{} is closely tied to the content of the place and
transition designs.  We present the syntax of \hvhdl{} in a bottom-up
manner, starting from expressions to higher constructs.

\begin{table}[!htbp]
  \caption{Expressions}
  \label{tab:expr}
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $e$ & ::= $name$ & read a signal, a local variable \\
    & & or a generic constant value \\
    & \quad $\vert{}~cst$ & constant \\
    & \quad $\vert{}~bop$($e_1$, $e_2$) & binary operation \\
    & \quad $\vert{}~uop$($e$) & unary operation \\
    & \quad $\vert{}~$\texttt{(}$e^{+}$\texttt{)} & aggregate expression \\
    & & \\
    $name$ & ::= $id$ & read a signal, local variable, \\
    & & or generic constant value \\
    & \quad$\vert{}~$ $id$\texttt{(}$e$\texttt{)} & read value of an array signal  \\
    & & or local variable at index $e$ \\
    & & \\
    $cst$ & ::= $n$ $\vert{}~$ $b$ & natural or Boolean \\
    & & \\
    $bop$ & ::= \texttt{and} $\vert{}$ \texttt{or} & Boolean operators \\
    & \quad$\vert{}$ \texttt{add} $\vert{}$ \texttt{sub} & natural number arithmetic \\
    & \quad$\vert{}$ \texttt{eq} $\vert{}$ \texttt{ne} $\vert{}$ \texttt{gt} $\vert{}$ \texttt{ge} $\vert{}$ \texttt{lt} $\vert{}$ \texttt{le} & comparisons \\
    & & \\
    $uop$ & ::= \texttt{not} & Boolean negation \\
    & & \\
    \hline
  \end{tabular}
\end{table}

The expressions of \hvhdl{} are restrained to operations over Boolean
or natural numbers that are used in the designs generated by the
transformation, and more particularly the ones used in the pre-defined
place and transition designs.

\begin{table}[!htbp]
  \caption{Sequential statements}
  \label{tab:ss}
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $ss$ & ::= $name~\mathtt{\Leftarrow}~e$ & assignment to a signal \\
    & \quad$\vert{}~name~\mathtt{:=}~e$ & assignment to a local variable \\
    & \quad$\vert{}~\mathtt{if}(e)\{ss_1\}~\mathtt{else}~\{ss_2\}$ & conditional \\
    & \quad$\vert{}~\mathtt{for}(id,e_1,e_2)\{ss\}$ & range loop \\
    & \quad$\vert{}~\mathtt{falling}\{ss\}$ & falling edge block \\
    & \quad$\vert{}~\mathtt{rising}\{ss\}$ & rising edge block \\
    & \quad$\vert{}~\mathtt{rst}~\{ss_1\}~\mathtt{else}~\{ss_2\}$ & reset conditional \\
    & \quad$\vert{}~ss_1\mathtt{;}ss_2$ & sequence \\
    & \quad$\vert{}~\mathtt{null}$ & no operation \\
    & & \\
    \hline
  \end{tabular}
\end{table}

Sequential statements are used to defined the body of processes, and
mainly act upon the value of signals and local variables through
assignment operations. The set of sequential statement includes the
classical conditional, range loop, and sequence statements. We add
particular statements, namely the falling edge, rising edge and reset
conditional statements, derived from the concrete syntax of \vhdl{}.
These statements are convenient to express block of statements to be
executed only at certain phases of the simulation.

\todo[inline]{Show the corresponding VHDL code represented by falling,
  rising and rst blocks.}

\begin{table}[!htbp]
  \caption{Type indication}
  \label{tab:typeind}
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $\tau$ & ::= \texttt{bool} & boolean \\
    & \quad$\vert{}~$ \texttt{nat} \texttt{(}$e_1$\texttt{,} $e_2$\texttt{)} & natural range $e_1$ to $e_2$ \\
    & \quad$\vert{}~$ \texttt{array} \texttt{(}$\tau$\texttt{,} $e_1$\texttt{,} $e_2$\texttt{)} & array of $\tau$ with index range $e_1$ to $e_2$ \\
    & & \\
    \hline
  \end{tabular}
\end{table}

A type indication informs us about the type of a given signal, local
variable, or generic constant at the time of its declaration. A
signal, a local variable or a generic constant can be a Boolean, a
natural number defined in a certain range, or an array of elements
associated with a certain type indication.

\begin{table}[!htbp]
  \caption{Concurrent statements}
  \label{tab:cs}
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $cs$ & ::= $ps$ & process statement \\
    & $\vert{}~$ $comp$ & design instantiation statement \\
    & $\vert{}~$ $cs_1~\mathtt{||}~cs_2$ & parallel composition \\
    & $\vert{}~$ \texttt{null} & no operation \\
    & & \\
    $ps$ & ::= $\mathtt{ps}(id_p,$ & process identifier \\
    & \quad\quad\quad${}vars=\{(id,\tau)^{*}\},$ & local variable declarations\\
    & \quad\quad\quad${}body=ss)$ & statement body \\
    & & \\
    $comp$ & ::= $\mathtt{comp}(id_c,$ & component instance identifier \\
      & \quad\quad\quad\quad$id_e,$ & instantiated design identifier \\
      & \quad\quad\quad\quad${}g=\{(id\Rightarrow{}e)^{*}\},$ & generic constant map \\
      & \quad\quad\quad\quad${}i=\{(name\Rightarrow{}e)^{*}\},$ & input port map \\
    & \quad\quad\quad\quad$o=\{\big((id\Rightarrow{}(name\vert{}\mathtt{open}))$ & output port map \\
    & \quad\quad\quad\quad\quad\quad\quad$\big\vert{}(id(e)\Rightarrow{}name)\big)^{*}\})$ &  \\
    & & \\
    \hline
  \end{tabular}

\end{table}

The behavior of a design is defined by concurrent statements. A
concurrent statement can be a process, a design instantiation, or the
parallel composition of two concurrent statements. A process statement
declares a set of local variables, and executes operations over
signals and variables defined in its sequential statement body. A
design instantiation statement represents the creation of a
subcomponent having a part in the definition of the embedding
design. A design instantiation statement indicates which design is
instantiated as a subcomponent (i.e. $id_e$). It also indicates how
the subcomponent is dimensioned through a generic constant map
(i.e. $g$). Moreover, it indicates how the subcomponent is connected
to the other parts of the embedding design through a input port
(i.e. $i$) and output port map (i.e. $o$).

\begin{table}[!htbp]
  \caption{Design}
  \label{tab:design}
  \begin{tabular}{|rll|}
    \hline
    & & \\
    $design$ & ::= $\{{}gens=\{(id,\tau,e)^{*}\},$ & generic constants \\
    & \quad\quad${}ports=\{((\mathtt{in}\vert\mathtt{out}),id,\tau)^{*}\},$ & input and output ports \\
    & \quad\quad${}sigs=\{(id,\tau)^{*}\},$ & internal signals \\
    & \quad\quad${}beh=cs\}$ & design behavior \\
    & & \\
    \hline
  \end{tabular}
\end{table}

The highest construct of the \hvhdl{} language is the design. A design
represents a whole circuit by itself. Once defined, a design can be
later be instantiated to define the behavior of other designs. A
design that is not instantiated as a part of the behavior of another
design is referred to as a \textit{top-level} design. A design
declares a set of generic constants (i.e. \textit{gens}) which purpose
is to dimension the other parts of the circuit. A design also declares
a set of input and output ports (i.e. $ports$), and a set of internal
signals (i.e. $sigs$). Finally, a design declares an internal behavior
(i.e. $behavior$) which is defined by a concurrent statement.

\todo[inline]{Give an example of \vhdl{} design in concrete and
  abstract syntax.}

\subsection{Simulation semantics}
\label{subsec:sim-semantics}

The \vhdl{} Language Reference Manual\cite{VHDL2000} defines the
semantics of a \vhdl{} design with a simulation algorithm. The
simulation algorithm is informally presented in the LRM. Many
formalization of the algorithm exist in the scientific
literature\cite{Borger1995,Borrione1995,Breuer1994,Breuer1995,Breuer1995a,Deharbe1995,Dohmen1995,Fuchs1995,Goossens1995,Kloos2012,Olcoz1995,Pandey1999,Reetz1995,Shankar1997,Thirunarayan2001,VanTassel1995}. Considering
our specific needs regarding the \vhdl{} designs generated by the
\hilecop{} transformation, a particular simulation semantics has been
defined for the \hvhdl{} language. We give a simpler formal definition
of the simulation algorithm. The simplification of the algorithm is a
consequence of two characteristics of the \hvhdl{} designs. First, the
\hilecop{}-generated \hvhdl{} designs are \textit{synthezisable},
i.e. they target a physical implementation. Thus, certain constructs
of the \vhdl{} language such as wait statements, unit-delay signal
assignments (a.k.a. timed constructs) are not considered, as they can
not lead to a physical implementation. Removing the timed constructs
from the subset of \vhdl{} we are dealing with considerably simplifies
the expression of the simulation algorithm. Second, the
\hilecop{}-generated \hvhdl{} designs are \textit{synchronous},
i.e. the execution of certain parts of their behavior is triggered by
certain events of a clock signal. Thus, the expression of our
simulation algorithm explicitly takes into account the clock signal
events. In what follows, we give a formal definition of the simulation
algorithm that gives a semantics to the execution of \hvhdl{}
designs. Our semantics takes the form of a big-step operational
semantics. Our main inspirations were the operational semantics of
J. Van Tassel\cite{VanTassel1995}, and the denational semantics for a
synchronous subset of \vhdl{} by D. Borrione\cite{Borrione1995}. The
rules of the semantics will be presented in a bottom-up manner,
starting from the evaluation of expressions to the definition of the
whole simulation algorithm.

\subsubsection{Semantic domains}
\label{subsubsec:sem-domains}

Before detailling the semantics rules, we must introduce the $type$
and $value$ sets representing the types and values of the
semantics. We must also introduce the definitions of an elaborated
design, and the notion of design state, as the simulation of a design
computes the evolution of a design state through multiple clock
cycles. We also introduce here some mandatory definitions such as the
typing relation $\in_c$, or the predicate qualifying static
expressions.

\begin{table}[!htbp]
  \caption{The $t$ (type) and $v$ (value) semantic types.}
  \label{tab:type-value}

  \begin{tabular}{|rll|}
    \hline
    && \\
    $t$ & ::= $\mathtt{bool}$ & Boolean type \\
    & \quad $\vert~\mathtt{nat}(n_1$, $n_2)$ & natural range $n_1$ to $n_2$ \\
    & \quad $\vert~\mathtt{array}(t, n_1, n_2)$ & array of $t$ with index range $n_1$ to $n_2$ \\
    & & \\
    $v$ & ::= $b$ & Boolean \\
    & \quad $\vert~{}n$ & natural number (limited to $\mathtt{NATMAX}$) \\
    & \quad $\vert~a$ & array of values \\
    $a$ & ::= $(v^{+})$ & \\
    \hline
  \end{tabular}    
\end{table}

In Table~\ref{tab:type-value}, the $type$ set directly reflects the
type indication set used in the abstract syntax of \hvhdl{}. In the
$type$ set, the bounds of a natural number range and the index range
of an array have all been evaluated to natural numbers. In the
\hvhdl{} semantics, a value can be a Boolean, a natural number, or an
array of values. $\mathtt{NATMAX}$ denotes the maximum value for a
natural number.  The $\mathtt{NATMAX}$ value depends on the
implementation of the \textsf{VHDL} language; $\mathtt{NATMAX}$ must
at least be equal to $2^{31}-1$.

Now, let us define the structure of \textit{elaborated design}. An
elaborated design is built during the elaboration of a \hvhdl{}
design. Then, the elaborated design will act as a runtime environment
in the expression of the simulation rules. The elaboration phase
corresponds to the creation of the global environment of the
simulation. During the elaboration phase as described in the LRM, a
design is statically type-checked, and certain tests are performed
regarding the well-formedness of the design (e.g. connections in port
maps, multiply-driven signals, etc.). In the LRM, the elaboration
phase also involves the transformation of design instantiation
statements into \textit{block} statements; it corresponds to the
flattening of the structure of subcomponents brought by the design
instantiation statements. We have formally defined the elaboration
phase through an elaboration relation. In our formalization, we do not
take into account the transformation of design instantiation
statements into block statements. For the purpose of the proof of
semantic preservation, we are interested in preserving the
hierarchical structure provided by the design instantiation
statements, arguing that it permits us to better relate the structure
of a SITPN model to the structure of the corresponding \hvhdl{} design
obtained through the \hilecop{} transformation. The full formalization
of the elaboration relation is presented here\cite{Iampietro2021}.

Let $ElDesign$ be the set of elaborated designs. An elaborated design
is a composite environment built out of multiple sub-environments.
Each sub-environment is a table, represented as a function, mapping
identifiers of a certain category of constructs (e.g, input port
identifiers) to their declaration information (e.g, type indication
for input ports). We represent an elaborated design as a record where
the fields are the sub-environments. An elaborated design is defined
as follows:

\begin{definition}[Elaborated design]
  \label{def:elab-design}
  An elaborated design $\Delta\in{}ElDesign$ is a record\\
  ${<}G, I, O, S, P, C{>}$ where:
  \begin{itemize}[label=$-$]
  \item $G\in{}id\nrightarrow{}(t\times{}v)$
    is the function yielding the type and the value of generic
    constants.
  \item $I\in{}id\nrightarrow{}t$ is the function
    yielding the type of input ports.
  \item $O\in{}id\nrightarrow{}t$ is the function
    yielding the type of output ports.
  \item
    $S\in{}id\nrightarrow{}t$
    is the function yielding the type of declared signals.
  \item $P\in{}id\nrightarrow(id\nrightarrow{}(t\times{}v))$ is the
    function associating process identifiers to their local variable
    environment.
  \item $C\in{}id{}\nrightarrow{}ElDesign$ is the function mapping
    design instance identifiers to their own elaborated design
    version.
  \end{itemize}
\end{definition}

We assume that there is no overlapping between the identifiers of the
sub-environments of an elaborate design (i.e, an identifier belongs to
at most one sub-environment), and also between the identifiers of the
sub-environments and the identifiers of local environments. When there
is no ambiguity, we write $\Delta(x)$ to denote the value returned for
identifier $x$, where $x$ is looked up in the appropriate field of
$\Delta$. We write $x\in\Delta$ to state that identifier $x$ is
defined in the domain of one of $\Delta$'s field. We note
$\Delta(x)\leftarrow{}v$ the overriding of the value associated to
identifier $x$ with value $v$ in the appropriate field of $\Delta$,
$\Delta\cup{}(x,v)$ to note the addition of the mapping from
identifier $x$ to value $v$ in the appropriate field of $\Delta$, that
assuming $x\notin\Delta$. We write $x\in\mathcal{F}(\Delta)$, where
$\mathcal{F}$ is a field of $\Delta$, when more precision is needed
regarding the lookup of identifier $x$ in the record $\Delta$.\\

Now let us define the run-time state of a design, i.e. the state that
describes the value of signals and design instances in the course of a
simulation. Let $\Sigma$ be the set of design states.  A design state
of $\sigma\in{}\Sigma$ is defined as follows:

\begin{definition}[Design state]
  \label{def:design-state}
  A design state $\sigma\in\Sigma$ is a couple
  $(\mathcal{S},\mathcal{C})$ where:
  \begin{itemize}[label=$-$]
  \item $\mathcal{S}\in{}id\nrightarrow{}v$ is the signal store,
    i.e. the function yielding the current value of signals
    (i.e. ports and internal signals).
  \item $\mathcal{C}\in{}id\nrightarrow{}\Sigma$ is the design
    instance store, i.e.  the function yielding the current state of
    design instances.
  \end{itemize}
\end{definition}

When there is no ambiguity regarding which store a given identifier
belongs to, we use $\sigma(id)$ as a shorthand notation for
$\mathcal{S}(\sigma)(id)$ or $\mathcal{C}(\sigma)(id)$.  Similarly, we
write $id\in\sigma$ as a shorthand notation for
$id\in\mathsf{dom}(\mathcal{S}(\sigma))$ or
$id\in\mathsf{dom}(\mathcal{C}(\sigma))$.

\subsubsection{Evaluation of expressions}
\label{subsubsec:expr-eval}

In what follows, we use the option type to express partial functions,
or functions that can return errors.  We write
$f(x)=\lfloor{}y\rfloor$ to state that some value $y$ is associated
with the input $x$ through function $f$; we write $f(x)=\emptyset$ to
state that either $x$ is not the definition domain of $f$, or that an
error is returned for the input $x$.

Table~\ref{tab:expr-eval} presents the rules to evaluate the
expressions defined in the \hvhdl{} abstract syntax. A rule instance
of the expression evaluation relation is written
$\Delta,\mathcal{S},\Lambda\vdash{}e\xrightarrow{e}v$, where
$\Delta\in{}ElDesign$ is an elaborated design,
$\mathcal{S}\in{}id\nrightarrow{}v$ is a signal store,
$\Lambda\in{}id\nrightarrow(t\times{}v)$ is a local variable
environment, $e$ is an expression and $v$ the value resulting from the
evaluation of $e$.

When the evaluated expression is an identifier, the associated value
is looked up in the appropriate location, i.e. in the signal store for
a signal identifier, in the local environment for a local variable or
in the elaborated design for a generic constant. Note that the
expression evaluation relation is deterministic only if the definition
domains of $G(\Delta)$ (i.e. the generic constants of $\Delta$), the
signal store $\mathcal{S}$ and the local variable environment
$\Lambda$ are not overlapping. We enforce this property through the
elaboration of the design that comes before the simulation. We add a
rule to evaluate an identifier expression that refers to an output
port identifier. Normally, output ports are write-only constructs,
however, we must be able to read their value to evaluate output port
maps in design instantiation statements. We write
$\Delta,\mathcal{S},\Lambda\vdash{}e\xrightarrow{e_o}v$ to enable the
reading of output port identifiers through the expression evaluation
relation.

In Table~\ref{tab:expr-eval}, we also give an example of evaluation of
an indexed identifier expression in the case where the identifier is
an input port or an internal signal. The rule checks that an array is
associated with identifier in the signal store $\mathcal{S}$, then the
index of reading is computed. In the \hvhdl{} language, the index
range of an array type does not necessarily start from zero. This
feature is convenient to represent, for instance, a binary word with
multiple composite signals, e.g. one representing bits 0 to 7, the
other bits 8 to 16, etc. However, in our semantics, all arrays start
from the index 0, and we must explicitly convert the index to a zero
starting range when evaluating an indexed identifier expression. In
Table~\ref{tab:expr-eval}, we omit the evaluation rules for the cases
of an indexed local variable identifier and an indexed output port
identifier as they are almost similar to the given example. We use to
primitive operations to read from and to write to an array at a
certain index. We write $a[i]$ when reading from an array $a$ at index
$i$, and $a[i]\leftarrow{}x$ to write $x$ at the position $i$ in array
$a$. Both operations return an error if the index $i$ is out of the
array bounds.

The evaluation of binary operators mostly relies on the definition of
the $\mathtt{vbop}$ function. We present some of the definition cases
of the $\mathtt{vbop}$ function in Table~\ref{tab:expr-eval}.

\begin{table}[!t]
  \caption{Semantics for \hvhdl{} expressions}
  \label{tab:expr-eval}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Sig}} \\
    {\begin{prooftree}
        \hypo{\mathcal{S}(id)=\lfloor{}v\rfloor}
        \infer1
        [{
          \begin{tabular}{@{}l}
            ${}id\in{}S(\Delta)\cup{}I(\Delta)$ \\
          \end{tabular}
        }]
        {
          \Delta,\mathcal{S},\Lambda\vdash{}id\xrightarrow{e}v
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Var}} \\
    {\begin{prooftree}
        \hypo{\Lambda({}id)=\lfloor(t,v)\rfloor}
        \infer1
        {
          \Delta,\mathcal{S},\Lambda\vdash{}id\xrightarrow{e}v
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Gen}} \\
    {\begin{prooftree}
        \hypo{G(\Delta)(id)=\lfloor(t,v)\rfloor}
        \infer1
        []
        {
          \Delta,\mathcal{S},\Lambda\vdash{}id\xrightarrow{e}v
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{10pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Out}} \\
    {\begin{prooftree}
        \hypo{\mathcal{S}(id)=\lfloor{}v\rfloor}
        \infer1
        [{
          \begin{tabular}{@{}l}
            ${}id\in{}O(\Delta)$ \\
          \end{tabular}
        }] {
          \Delta,\mathcal{S}\vdash
          {}id
          \xrightarrow{e_o}
          v
        }
      \end{prooftree}} \\
  \end{tabular}
    \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Cst}} \\
    {\begin{prooftree}
        \hypo{\mathtt{vcst}(cst)=\lfloor{}v\rfloor}
        \infer1
        {
          \Delta,\mathcal{S},\Lambda\vdash{}cst\xrightarrow{e}v
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{10pt}
  
  % Idx name expressions.
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{IdxSig}} \\
    {\begin{prooftree}

        % Evaluates e_i.
        \hypo{\Delta,\mathcal{S},\Lambda\vdash{}e_i\xrightarrow{e}n_i}

        % Reading array a at index i yields value v. 
        \hypo{a[i]=\lfloor{}v\rfloor}
        
        % Conclusion.
        \infer2
        [{
          \begin{tabular}{@{}l}
            ${}id\in{}S(\Delta)\cup{}I(\Delta)$ \\
            $\Delta(id)={}\lfloor\mathtt{array}(t,n,m)\rfloor$ \\
            $\mathcal{S}(id)={}\lfloor{}a\rfloor$ \\
            $i=n_i-n$ \\
          \end{tabular}
        }]
        {
          \Delta,\mathcal{S},\Lambda\vdash
          {}id({}e_i)
          \xrightarrow{e}
          v
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{10pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{BOp}}  \\
    {\begin{prooftree}

        % Evaluates e1.
        \hypo{\Delta,\mathcal{S},\Lambda\vdash{}e_1\xrightarrow{e}v_1}

        % Evaluates e2.
        \hypo{\Delta,\mathcal{S},\Lambda\vdash{}e_2\xrightarrow{e}v_2}

        % Evaluates bop(v1,v2).
        \hypo{\mathtt{vbop}(bop,v_1,v_2)=\lfloor{}v\rfloor}

        % Conclusion.
        \infer3
        {
          \Delta,\mathcal{S},\Lambda\vdash
          bop(e_1,e_2)\xrightarrow{e}v
        }
      \end{prooftree}}\\
  \end{tabular}

  \vspace{10pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Not}} \\    
    {\begin{prooftree}

        % Evaluates e.
        \hypo{\Delta,\mathcal{S},\Lambda\vdash{}e\xrightarrow{e}b}
        
        % Conclusion.
        \infer1
        {
          \Delta,\mathcal{S},\Lambda\vdash\mathtt{not}(e)\xrightarrow{e}\lnot{}b
        }
      \end{prooftree}} \\
  \end{tabular}
  % Aggregate.
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Aggreg}} \\
    {\begin{prooftree}

        % Evaluates e.
        \hypo{\Delta,\mathcal{S},\Lambda\vdash{}e_i\xrightarrow{e}v_i}

        % Conclusion.
        \infer1
        [$i=1,\dots,n$]
        {
          \Delta,\mathcal{S},\Lambda\vdash\mathtt{(}{}e_1,\dots,{}e_n\mathtt{)}\xrightarrow{e}(v_1,\dots,v_n)
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{10pt}

  \textbf{Evaluation of binary constants:}
  \begin{eqnarray*}
    \label{eq:vcst}
    \mathtt{vcst}(b) & = & \lfloor{}b\rfloor \\
    \mathtt{vcst}(n) & = & \begin{cases}
                             \lfloor{}n\rfloor~\mathrm{if}~n\le\mathtt{NATMAX} \\
                             \emptyset~\mathrm{otherwise} \end{cases} \\
  \end{eqnarray*}
  
  \textbf{Evaluation of binary operators (selected cases):}
  \begin{eqnarray*}
    \label{eq:vbop}
    \mathtt{vbop}(\mathtt{and}, b_1, b_2) & = & \lfloor{}b_1~\&\&~b_2\rfloor \\
    \mathtt{vbop}(\mathtt{add}, n_1, n_2) & = & \begin{cases}
                                                  \lfloor{}n_1+n_2\rfloor~\mathrm{if}~n_1+n_2\le\mathtt{NATMAX} \\
                                                  \emptyset~\mathrm{otherwise} \end{cases} \\
    \mathtt{vbop}(\mathtt{sub}, n_1, n_2) & = & \begin{cases}
                                                  \lfloor{}n_1-n_2\rfloor~\mathrm{if}~n_1\ge{}n_2 \\
                                                  \emptyset~\mathrm{otherwise}
                                                \end{cases} \\
  \end{eqnarray*}
  
\end{table}

\subsubsection{Evaluation of sequential statements and port maps}
\label{subsubsec:ss-and-port-map-eval}

Table~\ref{tab:ss-eval} describes the evaluation of sequential
statements. Sequential statements define the body of processes
composing the behavior of a \hvhdl{} design.

\begin{table}[h]

  \caption{Evaluation of sequential statements}
  \label{tab:ss-eval}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{SigAssign}} \\
    {\begin{prooftree}

        % Evaluates e.
        \hypo{\Delta,\mathcal{S}_r,\Lambda\vdash{}e\xrightarrow{e}v}
        
        % Checks that v complies with t.
        \hypo{v\in_c{}t}
        
        % Conclusion.
        \infer2
        [{\begin{tabular}{l}
            $id\in{}S(\Delta)\cup{}O(\Delta)$ \\
            $\Delta(id)=\lfloor{}t\rfloor$ \\
          \end{tabular}
        }]
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          {}id\Leftarrow{}e
          \xrightarrow{ss}
          \mathcal{S}_w(id)\leftarrow{}v,\Lambda
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{VarAssign}} \\ 
    {\begin{prooftree}

        % Evaluates e.
        \hypo{\Delta,\mathcal{S}_r,\Lambda\vdash{}e\xrightarrow{e}v}

        % Checks that v complies with t.
        \hypo{v\in_c{}t}

        % Conclusion.
        \infer2[$\Lambda(id)=\lfloor(t,val)\rfloor$]
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          {}id:={}e
          \xrightarrow{ss}
          \mathcal{S}_w,\Lambda(id)\leftarrow{}(t,v)
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  % \begin{tabular}{@{}l}
  %   % {\fontsize{10}{13}\selectfont\textsc{IdxSigAssign}} \\
  %   {\begin{prooftree}

  %       % Evaluates e_i and e.
  %       \hypo{\Delta,\mathcal{S}_r,\Lambda&\vdash{}e_i\xrightarrow{e}n_i}
  %       \infer[no rule]1{\Delta,\mathcal{S}_r,\Lambda&\vdash{}e\xrightarrow{e}v}

  %       % Checks that v complies with t.

  %       \hypo{v&\in_c{}t}
  %       \infer[no rule]1{n_i&\in_c{}\mathtt{nat}(n,m)}
        
  %       % Conclusion.
  %       \infer2
  %       [{\begin{tabular}{@{}l}
  %           ${}id\in{}S(\Delta)\cup{}O(\Delta)$ \\
  %           $\Delta(id)=\lfloor\mathtt{array}(t,n,m)\rfloor$ \\
  %           $\mathcal{S}_w(id)=\lfloor{}a\rfloor$, $i=n_i-n$ \\
  %           $a[i]\leftarrow{}v=\lfloor{}a'\rfloor$ \\
  %         \end{tabular}
  %       }]
  %       {
  %         \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
  %         {}id(e_i)\Leftarrow{}e
  %         \xrightarrow{ss}
  %         \mathcal{S}_w(id)\leftarrow{}a',\Lambda
  %       }
  %     \end{prooftree}} \\
  % \end{tabular}

  % \begin{tabular}{@{}l}
  %   {\fontsize{10}{13}\selectfont\textsc{IdxVarAssign}} \\    
  %   {\begin{prooftree}

  %       % Evaluates e_i.
  %       \hypo{\Delta,\mathcal{S}_r,\Lambda&\vdash{}e_i\xrightarrow{e}n_i}
  %       \infer[no rule]1{\Delta,\mathcal{S}_r,\Lambda&\vdash{}e\xrightarrow{e}v}

  %       % Checks that v complies with T.
  %       \hypo{n_i&\in_c{}\mathtt{nat}(n,m)}
  %       \infer[no rule]1{v&\in_c{}t}

  %       % Conclusion.
  %       \infer2
  %       [{
  %         \begin{tabular}{@{}l}
  %           $\Lambda(id)=\lfloor\big(\mathtt{array}(t,n,m),a\big)\rfloor$ \\
  %           $i=n_i-n$ \\
  %           $a[i]\leftarrow{}v=\lfloor{}a'\rfloor$ \\
  %         \end{tabular}
  %       }]
  %       {
  %         \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
  %         {}id(e_i):={}e
  %         \xrightarrow{ss}
  %         \mathcal{S}_w,\Lambda(id)\leftarrow{}(t,a')
  %       }
  %     \end{prooftree}} \\
  % \end{tabular}

  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{IfElse}$\top$} \\    
    {\begin{prooftree}

        % Evaluates condition.
        \hypo{\Delta,\mathcal{S}_r,\Lambda\vdash{}e\xrightarrow{e}\mathtt{true}}

        % Evaluates ss.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss_1\xrightarrow{ss}\mathcal{S}'_w,\Lambda'}

        % Conclusion.
        \infer2
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{if}(e)\{ss_1\}\mathtt{else}\{ss_2\}
          \xrightarrow{ss}
          \mathcal{S}'_w,\Lambda'
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{IfElse}$\bot$} \\  
    {\begin{prooftree}

        % Evaluates condition.
        \hypo{\Delta,\mathcal{S}_r,\Lambda\vdash{}e\xrightarrow{e}\mathtt{false}}

        % Evaluates ss.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss_2\xrightarrow{ss}\mathcal{S}'_w,\Lambda'}

        % Conclusion.
        \infer2
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash~
          \mathtt{if}(e)\{ss_1\}\mathtt{else}\{ss_2\}
          \xrightarrow{ss}
          \mathcal{S}'_w,\Lambda'
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Loop}$\bot$} \\
    {\begin{prooftree}

        % Evaluates upper bound check.
        \hypo{\Delta,\mathcal{S}_r,\Lambda\vdash{}e_2>0\xrightarrow{e}\mathtt{true}}
        \infer[no rule]1{\Delta,\mathcal{S}_r,\Lambda\vdash{}e_1\xrightarrow{e}v_1}
        \infer[no rule]1{v_1\in_c\mathtt{nat}(0,\mathtt{NATMAX})}
        
        % Evaluates ss and recursive call.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda(id)\leftarrow{}\big(\mathtt{nat}(0,\mathtt{NATMAX}),v_1\big)
          \vdash{}ss\xrightarrow{ss}\mathcal{S}'_w,\Lambda'}
        
        \infer[no rule]1{ \Delta,\mathcal{S}_r,\mathcal{S}'_w,\Lambda'\vdash
          \mathtt{for}(id,e_1+1,e_2-1)\{ss\}
          \xrightarrow{ss}\mathcal{S}''_w,\Lambda''
        }
        
        % Conclusion. 
        \infer2[]
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{for}(id,e_1,e_2)\{ss\}
          \xrightarrow{ss}
          \mathcal{S}''_w,\Lambda''
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Loop}$\top$} \\    
    {\begin{prooftree}
        
        % Upper bound check true.
        \hypo{\Delta,\mathcal{S}_r,\Lambda\vdash{}e_2=0\xrightarrow{e}\texttt{true}}

        % Conclusion.
        \infer1[]
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{for}(id,e_1,e_2)\{ss\}
          \xrightarrow{ss}
          \mathcal{S}_w,\Lambda\setminus\{id\}
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{RisingEdgeDefault}} \\    
    {\begin{prooftree}

        \hypo{f\in\{\downarrow,i,c\}}
        
        % Conclusion.
        \infer1
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{rising}\{ss\}
          \xrightarrow{ss_f}
          \mathcal{S}_w,\Lambda
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{RisingEdgeExec}} \\    
    {\begin{prooftree}

        % Evaluates ss.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss\xrightarrow{ss_\uparrow}\mathcal{S}'_w,\Lambda'}
        
        % Conclusion.
        \infer1
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{rising}\{ss\}
          \xrightarrow{ss_\uparrow}
          \mathcal{S}'_w,\Lambda'
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{FallingEdgeDefault}} \\    
    {\begin{prooftree}

        \hypo{f\in\{\uparrow,i,c\}}
        
        % Conclusion.
        \infer1{
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{falling}\{ss\}
          \xrightarrow{ss_f}
          \mathcal{S}_w,\Lambda
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{FallingEdgeExec}} \\    
    {\begin{prooftree}

        % Evaluates ss.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss\xrightarrow{ss_\downarrow}\mathcal{S}'_w,\Lambda'}
        
        % Conclusion.
        \infer1
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{falling}\{ss\}
          \xrightarrow{ss_\downarrow}
          \mathcal{S}'_w,\Lambda'
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{RstDefault}} \\    
    {\begin{prooftree}

        % Evaluates ss.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss_2\xrightarrow{ss_f}\mathcal{S}'_w,\Lambda'}
        
        % Conclusion.
        \infer1
        [
        \begin{tabular}{@{}l@{}}
          $f\in\{\uparrow,\downarrow,c\}$ \\
        \end{tabular}
        ]
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{rst}\{ss_1\}\mathtt{else}\{ss_2\}
          \xrightarrow{ss_f}
          \mathcal{S}'_w,\Lambda'
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{RstExec}} \\    
    {\begin{prooftree}

        % Evaluates ss.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss_1\xrightarrow{ss_i}\mathcal{S}'_w,\Lambda'}
        
        % Conclusion.
        \infer1
        {
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash
          \mathtt{rst}\{ss_1\}\mathtt{else}\{ss_2\}
          \xrightarrow{ss_i}
          \mathcal{S}'_w,\Lambda'
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Seq}} \\
    {\begin{prooftree}
        
        % Evaluates ss.
        \hypo{\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss_1\xrightarrow{ss}\mathcal{S}'_w,\Lambda'}

        % Evaluates ss'.
        \infer[no rule]1{\Delta,\mathcal{S}_r,\mathcal{S}'_w,\Lambda'\vdash{}ss_2\xrightarrow{ss}\mathcal{S}''_w,\Lambda''}

        % Conclusion.
        \infer1{
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss_1\mathtt{;}~{}ss_2\xrightarrow{ss}\mathcal{S}''_w,\Lambda''
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Null}} \\
    {\begin{prooftree}        

        % Conclusion.
        \infer0{
          \Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash\mathtt{null}\xrightarrow{ss}\mathcal{S}_w,\Lambda
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

A rule instance of the sequential statement evaluation relation takes
the form
$\Delta,\mathcal{S}_r,\mathcal{S}_w,\Lambda\vdash{}ss\xrightarrow{ss}\mathcal{S}'_w,\Lambda'$
where $\Delta\in{}ElDesign$ is an elaborated design,
$\mathcal{S}_r,\mathcal{S}_w\in{}id\nrightarrow{}v$ are two signal
stores, one to read the value of signals and one to override the value
of signals, $\Lambda\in{}id\nrightarrow{}(t\times{}v)$ is the local
variable environment, $ss$ is a sequential statement, and
$\mathcal{S}'_w,\Lambda'$ are the new signal store and local variable
environment after the execution of $ss$.

The sequential statement that characterizes the \vhdl{} language is
the signal assignment statement. The evaluation of the signal
assignment statement is given in the first rule of
Table~\ref{tab:ss-eval}. An assignment operation can only be performed
on an internal signal or an output signal identifier as stated in the
side condition. Note that to evaluate the expression assigned to a
signal identifier, the $\mathcal{S}_r$ signal store is used, and the
new value of the signal is updated in the $\mathcal{S}_w$ signal
store.

\todo[inline]{Show the example of the swap.}

Multiple signal assignment operations written in sequence must be
interpreted as executed in parallel. For that reason, we need a
read-only signal store to interpret the expressions found in
sequential statements and another signal store to update the value of
signals. As a consequence, the evaluation of the sequence statement
(at the end of Table~\ref{tab:ss-eval}) uses the same signal store
$\mathcal{S}_r$ to execute both statement $ss_1$ and $ss_2$. Only the
update signal store $\mathcal{S}_w$ is modified and passed along from
the execution of one statement to the other. On the contrary, variable
assignment statements are interpreted in sequence. Each variable
assignment modifies the local variable environment, and the modified
environment is passed as an input to the next statement in the
sequence. Note that, in the absence of variable assignment statements
in its operands, the sequence operator is commutative, i.e. the order
in which the statements of the sequence are evaluated does not impact
the outcome of the evaluation.

To evaluate the sequential statements which execution are related to
specific parts of the simulation algorithm, we use a flag written as
an index of the $ss$ symbol above the arrow symbol. The flag is a
parameter of the relation. No flag means that the statement is
interpreted regardless of the value of the flag. To interpret rising
blocks (resp. falling blocks), the $\uparrow$ flag (resp. $\downarrow$
flag) must be on, otherwise the interpretation of such blocks is idle.
The first part of a reset block is interpreted only when the $i$ flag
is on ($i$ standing for \textit{initialization}). Otherwise, the
second part of the block is interpreted.

Table~\ref{tab:pmap-eval} describes the evaluation of input and output
port maps which are parts of design instantiation statements. 

\begin{table}[!h]
  \caption[Evaluation of port maps]{Evaluation of input and output port maps}
  \label{tab:pmap-eval}

    
  \begin{tabular}{l}
    {\begin{prooftree}

        % Evaluates e.
        \hypo{\Delta,\mathcal{S}\vdash{}e\xrightarrow{e}v}

        % Checks that v complies with t.
        \hypo{v\in_c{}t}

        % Conclusion.
        \infer2[{
          \begin{tabular}{@{}l}
            $id\in{}I(\Delta_c)$ \\
            $\Delta_c(id)=\lfloor{}t\rfloor$ \\
          \end{tabular}
        }]
        {
          \Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash
          (id\Rightarrow{}e)
          \xrightarrow{mip}
          \mathcal{S}_c(id)\leftarrow{}v
        }
      \end{prooftree}} \\
  \end{tabular}
  
  \vspace{5pt}

    \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{MopOpen}} \\
    {\begin{prooftree}

        % Conclusion
        \infer
        0
        {
          \Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash
          (id\Rightarrow\mathtt{open})
          \xrightarrow{mop}
          \mathcal{S}
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{5pt}

  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{MopSimple}} \\
    {\begin{prooftree}

        % Evaluates name.
        \hypo{\Delta_c,\mathcal{S}_c\vdash{}name\xrightarrow{e_o}v}

        % Checks that v complies with t.
        \hypo{v\in_c{}t}
        
        % Conclusion.
        \infer2
        [{\begin{tabular}{@{}l}
            $id\in{}S(\Delta)\cup{}O(\Delta)$ \\
            $\Delta(id)=\lfloor{}t\rfloor$ \\
          \end{tabular}
        }]
        {
          \Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash
          (name\Rightarrow{}id)
          \xrightarrow{mop}
          \mathcal{S}(id)\leftarrow{}v
        }
      \end{prooftree}} \\
  \end{tabular}

  % \begin{tabular}{@{}l}
  %   % {\fontsize{10}{13}\selectfont\textsc{MopPartial}} \\
  %   {\begin{prooftree}

  %       % Evaluates id_f and e_i.
  %       \hypo{&{}e_i\xrightarrow{e}n_i}
  %       \infer[no rule]1{&\Delta_c,\mathcal{S}_c\vdash{}name\xrightarrow{e_o}v}

  %       % Checks that v complies with t.
  %       \hypo{v&\in_c{}t}
  %       \infer[no rule]1{n_i&\in_c{}\mathtt{nat}(n,m)}

  %       % Conclusion.
  %       \infer2
  %       [{\begin{tabular}{l}
  %           ${}id\in{}S(\Delta)\cup{}O(\Delta)$ \\
  %           $\Delta(id)=\lfloor\mathtt{array}(t,n,m)\rfloor$ \\
  %           $i=n_i-n$ \\
  %           $\mathcal{S}(id)=\lfloor{}a\rfloor$ \\
  %           $a[i]\leftarrow{}v=\lfloor{}a'\rfloor$ \\
  %         \end{tabular}
  %       }]
  %       {
  %         \Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash
  %         (name\Rightarrow{}id(e_i))
  %         \xrightarrow{mop}
  %         \mathcal{S}(id)\leftarrow{}a'
  %       }
  %     \end{prooftree}} \\
  % \end{tabular}

  % \begin{tabular}{l}
  %   {\fontsize{10}{13}\selectfont\textsc{MopComp}} \\
    
  %   {\begin{prooftree}    
  %       % Evaluates mip on assoc.
  %       \hypo{\Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash{}assoc_{po}\xrightarrow{mop}\mathcal{S}'}

  %       % Evaluates mip on portmap.
  %       \hypo{\Delta,\Delta_c,\mathcal{S}',\mathcal{S}_c\vdash{}o\xrightarrow{mop}\mathcal{S}''}

  %       % Conclusion.
  %       \infer2
  %       {
  %         \Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash
  %         assoc_{po},o
  %         \xrightarrow{mop}\mathcal{S}''
  %       }
  %     \end{prooftree}} \\
  % \end{tabular}
\end{table}

An input port map is a mapping from expressions (possibly reading the
value of the signals of the embedding design) to the input ports of a
design instance. It is expressed as a list of associations between an
expression and an input port identifier.  All associations composing
an input port map are evaluated in sequence.  The evaluation of an
association modifies the signal store of the design instance that
declares the input port map. Thus, the relation that evaluates an
input port map association is written
$\Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash{}(name\Rightarrow{}e)\xrightarrow{mip}\mathcal{S}'_c$,
where $\Delta\in{}ElDesign$ is the elaborated embedding design,
$\Delta_c\in{}ElDesign$ is the elaborated design instance,
$\mathcal{S}\in{}id\nrightarrow{}v$ is the signal store of the
embedding design, $\mathcal{S}_c\in{}id\nrightarrow{}v$ is the signal
store of the design instance, $name$ is an input port identifier, $e$
is an expression, and $\mathcal{S}'_c$ is the signal store resulting
of the evaluation of the association. In Table~\ref{tab:pmap-eval}, we
give the example of the evaluation of an association between a simple
port identifier and an expression. The expression is evaluated in the
context of the embedding elaborated design $\Delta$ and the signal
store $\mathcal{S}$, and the result is assigned in signal store
$\mathcal{S}_c$ to the identifier $id$. Here, we do not show the
evaluation of an association between an indexed identifier and an
expression, and the evaluation of the sequence of associations
composing an input port map.

An output port map is a list of associations between the output ports
of a design instance to the internal signals or output ports of an
embedding design.  The evaluation an output port map modifies the
signal store of the embedding design by propagating the value of the
output ports of the design instance. The evaluation relation for an
output port map association is written
$\Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash{}assoc_{op}\xrightarrow{mop}\mathcal{S}'_c$,
where $\Delta\in{}ElDesign$ is the elaborated embedding design,
$\Delta_c\in{}ElDesign$ is the elaborated design instance,
$\mathcal{S}\in{}id\nrightarrow{}v$ is the signal store of the
embedding design, $\mathcal{S}_c\in{}id\nrightarrow{}v$ is the signal
store of the design instance,
$assoc_{op}::=(id\Rightarrow{}(name|\mathtt{open}))\big|(id(e)\Rightarrow{}name)$
is an output port map association, and $\mathcal{S}'_c$ is the signal
store resulting of the evaluation of the association. When an output
port is left unconnected is the output port map of a design instance,
it is connected to the \texttt{open} keyword. As shown in
Table~\ref{tab:pmap-eval}, the evaluation of an unconnected output
port does not impact the signal store of the embedding design. 

\subsubsection{Evaluation of concurrent statements}
\label{subsubsec:cs-eval}

Concurrent statements define the behavior of a \hvhdl{} design. The
execution of concurrent statements modify the state of the \hvhdl{}
design under simulation. Table~\ref{tab:cs-eval} describes the
relation that evaluates concurrent statements. The relation is written
$\mathcal{D},\Delta,\sigma\vdash{}cs\xrightarrow{cs_f}\sigma'$, where
$\mathcal{D}\in{}id\nrightarrow{}design$ is a design store,
$\Delta\in{}ElDesign$ is an elaborated design, $\sigma\in\Sigma$ is
the design state before the evaluation of concurrent statement $cs$,
$\sigma'\in\Sigma$ is the design state resulting after the execution
of $cs$, and $f\in\{i,\uparrow,\downarrow,c\}$ is a flag representing
the current phase of simulation under which the concurrent statement
$cs$ is evaluated.

\begin{table}[!h]
  \caption{Evaluation of concurrent statements}
  \label{tab:cs-eval}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Ps}} \\
    {\begin{prooftree}[template=\inserttext]
        
        % Runs seq.
        \hypo{$\Delta,\mathcal{S},\mathcal{S},\Lambda\vdash{}ss\xrightarrow{ss_f}{}\mathcal{S}',\Lambda'$}

        % Conlcusion.
        \infer1
        [{
          \begin{tabular}{@{}l}
            $\Delta(id)=\lfloor\Lambda\rfloor$\\
            $\sigma=(\mathcal{S},\mathcal{C})$ \\
          \end{tabular}
        }]
        {
          $\mathcal{D},\Delta,\sigma\vdash$
          $\mathtt{ps}(id, vars, ss)$
          $\xrightarrow{cs_f}(\mathcal{S}',\mathcal{C})$
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{10pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Comp}} \\
    {\begin{prooftree}[template=\inserttext]
        
        % Builds mapping for in ports.
        \hypo{$\Delta,\Delta_c,\mathcal{S},\mathcal{S}_c\vdash{}i\xrightarrow{mip}\mathcal{S}'_c$}
        
        % Executes component instance behavior.
        \infer[no rule]1{$\mathcal{D},\Delta_c,(\mathcal{S}'_c,\mathcal{C}_c)\vdash{}d.behavior\xrightarrow{cs_f}\sigma_c''$}
        
        % Builds mapping for out ports.
        \infer[no rule]1{
          $\Delta,\Delta_c,\mathcal{S},\mathcal{S}_c''\vdash$
          $o$
          $\xrightarrow{mop}$
          $\mathcal{S}'$
        }
        
        % Conclusion.
        \infer1
        [{\begin{tabular}{@{}l}
            $\mathcal{D}(id_e)=\lfloor{}d\rfloor$ \\
            $\Delta(id_c)=\lfloor\Delta_c\rfloor$\\
            $\sigma(id_c)=\lfloor\sigma_c\rfloor$ \\
            $\sigma=(\mathcal{S},\mathcal{C})$\\
            $\sigma_c=(\mathcal{S}_c,\mathcal{C}_c)$ \\
            $\sigma''_c=(\mathcal{S}''_c,\mathcal{C}''_c)$ \\
          \end{tabular}
        }]
        {
          $\mathcal{D},\Delta,\sigma\vdash$
          $\mathtt{comp}(id_c, id_e, g, i, o)$          
          $\xrightarrow{cs_f}$
          $(\mathcal{S}',\mathcal{C}(id_c)\leftarrow{}\sigma''_c)$
        }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{15pt}
  
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Par}} \\
    {\begin{prooftree}
        \hypo{\mathcal{D},\Delta,\sigma\vdash{}cs\xrightarrow{cs_f}\sigma'}
        \hypo{\mathcal{D},\Delta,\sigma\vdash{}cs'\xrightarrow{cs_f}\sigma''}
        \infer2{
          \mathcal{D},\Delta,\sigma\vdash{}cs~\mathtt{||}~{}cs'\xrightarrow{cs_f}
          \mathtt{merge}(\sigma,\sigma',\sigma'')
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{Null}} \\
    {\begin{prooftree}
        \infer0
        {
          \mathcal{D},\Delta,\sigma\vdash\mathtt{null}\xrightarrow{cs_f}\sigma
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

In Table~\ref{tab:cs-eval}, the evaluation of a process statement
modifies the signal store by executing the body of the process under
the current simulation flag $f$. The evaluation of design
instantiation statement modifies both the signal store and the design
instance store of the embedding design. The current state of the
design instance $id_c$ and its elaborated version, namely $\sigma_c$
and $\Delta_c$, are retrieved from the elaborated design $\Delta$ and
the state $\sigma$ (i.e. the elaborated version and the current state
of the embedding design). The design instance $id_c$ is an
instantiation of the design $id_e$ and thus to execute the design
instance $id_c$ amounts to execute the behavior of the design
$id_e$. The behavior of the design $id_e$ is retrieved from the design
store $\mathcal{D}$. Then, the evaluation of the design instance
$id_c$ follows a three-step procedure: first, the input port map of
the design instance is evaluated and produces a new signal store
$\mathcal{S}'_c$; second, the internal behavior of the design instance
is executed under the simulation flag $f$ and with the new signal
store $\mathcal{S}'_c$ resulting from the evaluation of the input port
map as input; third, the output port map of the design instance is
executed and modifies the signal store of the embedding design to
yield a signal store $\mathcal{S}'$. Finally, $\mathcal{S}'$ becomes
the signal store of the resulting state, and the state associated with
the design instance $id_c$ is overriden with the new state
$\sigma''_c$ in the design instance store $\mathcal{C}$.  The
evaluation of the parallel composition of two concurrent statements
$cs$ and $cs'$ executes the two statements individually with the same
starting state $\sigma$. The individual execution of the concurrent
statements yields two states $\sigma'$ and $\sigma''$. These states
are merged together, thanks to the \texttt{merge} function, with the
origin state $\sigma$ to yield the state resulting from the evaluation
of the parallel composition.

As presented in Listing~\ref{lst:merge-functionr}, the \texttt{merge}
function returns a new state based on the parameters $\sigma$,
$\sigma'$ and $\sigma''$. Here, $\sigma$ is intended to be an origin
state, and $\sigma'$ and $\sigma''$ are two states resulting from the
execution of two different concurrent statements. For each signal
identifier $id$, the signal store of the resulting state yields the
freshest value for $id$. If the value of $id$ has changed from state
$\sigma$ to state $\sigma'$, then the value of $id$ at state $\sigma'$
is returned. If the value of $id$ has changed from state $\sigma$ to
state $\sigma''$, then the value of $id$ at state $\sigma''$ is
returned; otherwise, the value of $id$ at state $\sigma$ is returned
(i.e. the value of $id$ has not changed).
% We choose to remove from the side condition of the rule
% \textsc{Par} that was stating the absence of multiply-driven signal,
% and of twin design instances. The two can be obtain after a successful
% elaboration phase.

\begin{lstlisting}[language=PseudoCoq,label={lst:merge-functionr},
caption={[The \texttt{merge} function.] The \texttt{merge} function that fuses together an origin state $\sigma$, with two states $\sigma'$ and $\sigma''$ generated by the execution of two \hvhdl{} concurrent statements.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Definition merge($\sigma$, $\sigma'$, $\sigma''$) :=
   let $\sigma$ = ($\mathcal{S}$, $\mathcal{C}$) in
   let $\sigma'$ = ($\mathcal{S}'$, $\mathcal{C}'$) in
   let $\sigma''$ = ($\mathcal{S}''$, $\mathcal{C}''$) in
   let $\mathcal{S}_m(id)$ = $\begin{cases} 
     \mathcal{S}'(id) & \mathtt{if}~\mathcal{S}'(id)\neq\mathcal{S}(id) \\ 
     \mathcal{S}''(id) & \mathtt{if}~\mathcal{S}''(id)\neq\mathcal{S}(id) \\
     \mathcal{S}(id) & \mathrm{otherwise}
   \end{cases}$ in
   let $\mathcal{C}_m(id)$ = $\begin{cases} 
     \mathcal{C}'(id) & \mathtt{if}~\mathcal{C}'(id)\neq\mathcal{C}(id) \\ 
     \mathcal{C}''(id) & \mathtt{if}~\mathcal{C}''(id)\neq\mathcal{C}(id) \\
     \mathcal{C}(id) & \mathrm{otherwise}
   \end{cases}$ in 
   ($\mathcal{S}_m$, $\mathcal{C}_m$).
\end{lstlisting}

For the \texttt{merge} function to be sound, there must be no signal
identifier, or design instance identifier, that has a value different
from $\sigma$ in both $\sigma'$ and $\sigma''$. For a signal
identifier, this refers to a case of multiply-driven signal, i.e. a
signal that is assigned in two different concurrent statements. For a
design instance identifier, this refers to a case of \textit{twin}
design instances, i.e. two design instances with the same
identifier. Both cases are prevented by a successful elaboration
phase.

% The \texttt{merge} function is correct if the three input design
% states assume the same domains in their signal store and design
% instance store, and also if there are no multiply driven signal,
% i.e. a signal that would have a value that is different from the
% original signal store $\mathcal{S}$ in both signal stores
% $\mathcal{S}'$ and $\mathcal{S}''$. In practice, the case where a
% design instance identifier could be associated with a different state
% in both design instance store $\mathcal{C}'$ and $\mathcal{C''}$ is
% not possible. Such a case could only arise if two design instances
% with the same identifier exist in a design's behavior, and such a
% design can never be elaborated.

\subsubsection{The simulation algorithm}
\label{subsubsec:sim-algo}

Now, let us introduce our formalization of the simulation algorithm
devised specifically for \hvhdl{} designs. Our algorithm is much
simpler than the one expressed in the \vhdl{} LRM\cite{VHDL2000} and
in other formalization of the \vhdl{} language
semantics\cite{Borger1995}, mostly due to the fact that we are
targetting a very precise subset of the language, free of time
constructs and with explicit synchronous blocks, aimed at the
expression of designs both synthesizable and synchronous. Our
simulation algorithm is fit for all such designs. Our aim is to
simplify as much as possible our formal setting to ease the proof of
semantic preservation and its mechanization. Simplifying as much as
possible the simulation algorithm will lead to straight-forward
reasoning at the time of proofs, whereas the formalization of
fully-fledged simulation algorithm, however not deprived of interests
(e.g. to set the formal specification of a \vhdl{} simulator), will
only contribute to add complexity to our proofs.

\paragraph{Stabilization}

The simulation of a \hvhdl{} design goes through multiple phases. Each
phase is related to the execution of a particular part of the design's
behavior. During a stabilization phase, all the combinational parts of
a design's behavior are executed. In the \hvhdl{} language, all
statements that are not enclosed in falling or rising blocks are
considered as combinational statements (with the exception of the
first part of reset blocks), and are thus executed during the
stabilization phase. In Table~\ref{tab:stabilization}, we define the
stabilization phase through a stabilization relation written
$\mathcal{D},\Delta,\sigma\vdash{}cs\xrightarrow{\rightsquigarrow}\sigma'$,
where $\mathcal{D}\in{}id\nrightarrow{}design$ is a design store,
$\Delta\in{}ElDesign$ is the elaborated version of the design being
simulated, $\sigma\in{}\Sigma$ is the design state at the beginning of
the stabilization phase, $cs$ is a concurrent statement representing
the behavior of the design being simulated, and $\sigma'\in\Sigma$ is
the design state at the end of the stabilization phase.

\begin{table}[!h]
  \caption{Evaluation of a \hvhdl{} design's behavior during a
    stabilization phase.}
  \label{tab:stabilization}
  
  \begin{tabular}{@{}l}
    % {\fontsize{10}{13}\selectfont\textsc{StabilizeEnd}} \\    
    {\begin{prooftree}[template=\inserttext]

        \hypo{$\mathcal{D},\Delta,\sigma\vdash{}cs\xrightarrow{cs_c}\sigma'$}
        \infer1[$\sigma\stackrel{\Sigma}{=}\sigma'$]
        {
          $\mathcal{D},\Delta,\sigma\vdash{}cs\xrightarrow{\rightsquigarrow}\sigma'$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    % {\fontsize{10}{13}\selectfont\textsc{StabilizeLoop}} \\
    {\begin{prooftree}[template=\inserttext]
        \hypo{$\mathcal{D},\Delta,\sigma\vdash{}cs\xrightarrow{cs_c}\sigma'$}
        \hypo{$\mathcal{D},\Delta,\sigma'\vdash{}cs\xrightarrow{\rightsquigarrow}\sigma''$}
        \infer2[$\sigma\stackrel{\Sigma}{\neq}\sigma'$]
        {
          $\mathcal{D},\Delta,\sigma\vdash{}cs\xrightarrow{\rightsquigarrow}\sigma''$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

As expressed in Table~\ref{tab:stabilization}, if after the execution
of $cs$, the starting state and the resulting state are equal
(i.e. the evaluation of the behavior does no longer affect the value
of signals or design instance states) regarding the
$\stackrel{\Sigma}{=}$ relation, then a stable state has been reached
and the stabilization phase ends.  Otherwise, the behavior is executed
with the resulting state as input until a stable state is reached. Note
that in the presence of combinational loops (i.e. when a signal that
is the target of an assignment operation refers to its own value in
the right part of the assignment), the execution of a design's
behavior possibly leads to an infinite stabilization loop.

The state equality relation is inductively defined as follows: two
states $\sigma,\sigma'\in{}\Sigma$ are \textit{state}-equal if the
value of the signals referenced in their signal store are equal, and
if the state of all design instances referenced in their design
instance store are state-equal. Namely:
$\sigma\stackrel{\Sigma}{=}\sigma'\equiv
\big(\forall{}id_s,~\mathcal{S}(\sigma)(id_s)=\mathcal{S}(\sigma')(id_s)\big)
\land\big(\forall{}id_c,~\mathcal{C}(\sigma)(id_c)\stackrel{\Sigma}{=}\mathcal{C}(\sigma')(id_c)\big)$

% \begin{table}[!h]

%   \caption{Evaluation of a \hvhdl{} design's behavior during the
%     initialization phase.}
%   \label{tab:init}
  
%   % {\fontsize{10}{13}\selectfont\textsc{Init}}
%   \begin{prooftree}[template=\inserttext]

%     % Run all processes once.
%     \hypo{$\mathcal{D},\Delta,\sigma\vdash\mathrm{cs}\xrightarrow{cs_i}{}\sigma'$}

%     % Stabilization phase after runinit.
%     \hypo{$\mathcal{D},\Delta,\sigma'\vdash\mathrm{cs}\xrightarrow{\rightsquigarrow}{}\sigma_0$}

%     % Conclusion.
%     \infer2
%     {
%       $\mathcal{D},\Delta,\sigma\vdash\mathrm{cs}\xrightarrow{init}\sigma_0$
%     }

%   \end{prooftree}
% \end{table}

\paragraph{Main loop and full simulation}



The rules of Table~\ref{tab:sim-loop} define the \hvhdl{} simulation
relation which is a relational definition of the simulation algorithm
given in a structural \textit{small-step} setting (i.e. all
intermediary states are preserved in a simulation trace).  The
relation written
$\mathcal{D},E_p,\Delta,\tau,\sigma\vdash{}cs\rightarrow\theta$. The
\hvhdl{} simulation relation associates the execution of a behavior
$cs$ with a simulation trace $\theta\in\mathtt{list}(\Sigma)$ in a
context $\mathcal{D},E_p,\Delta,\tau,\sigma$ where
$\mathcal{D}\in{}id\nrightarrow{}design$ is a design store,
$E_p\in\mathbb{N}\rightarrow(id\nrightarrow{}v)$ is a simulation
environment that will be used to update the value of primary input
ports at the beginning of each simulation cycle, $\Delta\in{}ElDesign$
is the elaborated version of the design under simulation, $\tau$ is
the number of clock cycles to be performed during the simulation, and
$\sigma$ is the design state at the beginning of the simulation. The
simulation trace $\theta$, which is a list of time-ordered design
states, is the result of the execution of the design behavior $cs$
during $\tau$ clock cycles. Here, $cs$ represents the behavior of the
\hvhdl{} design under simulation.

\begin{table}[!h]
  \caption{Simulation main loop}
  \label{tab:sim-loop}
  
    \begin{tabular}{l}
    % SIMULATION LOOP
    % {\fontsize{10}{13}\selectfont\textsc{SimLoop}} \\
    
    {\begin{prooftree}[template=\inserttext]
        
        % First column.
        % Rising
        \hypo{$\mathcal{D},\Delta,\mathtt{inj}(\sigma,E_p,\tau)\vdash{}cs\xrightarrow{cs_\uparrow}\sigma_\uparrow$}

        % Stabilize after rising.
        \infer[no rule]1{$\mathcal{D},\Delta,\sigma_\uparrow\vdash{}cs\xrightarrow{\rightsquigarrow}\sigma'$}

        % Falling
        \infer[no rule]1{$\mathcal{D},\Delta,\sigma'\vdash{}cs\xrightarrow{cs_\downarrow}\sigma_\downarrow$}
        
        % Stabilize after falling.
        \infer[no rule]1{$\mathcal{D},\Delta,\sigma_\downarrow\vdash{}cs\xrightarrow{\rightsquigarrow}\sigma''$}

        % Second column.
        \hypo{$\mathcal{D},E_p,\Delta,\tau-1,\sigma''\vdash{}cs\rightarrow\theta$}
        
        \infer2 [$\tau>0$] {
          $\mathcal{D},E_p,\Delta,\tau,\sigma\vdash{}cs\rightarrow(\sigma'
          :: \sigma'' :: \theta)$ }
      \end{prooftree}} \\
  \end{tabular}

  \vspace{10pt}
  
  \begin{tabular}{l}
    %%% SIMULATION END.
    
    % {\fontsize{10}{13}\selectfont\textsc{SimEnd}} \\
    
    {\begin{prooftree}[template=\inserttext]
        \infer0 {
          $\mathcal{D},E_p,\Delta,0,\sigma\vdash{}cs\rightarrow{}[~]$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}


The \hvhdl{} simulation relation is defined through two rule
instances.  In the case where $\tau$ is equal to zero, the simulation
ends and the execution of $cs$ returns an empty trace. In the case
where $\tau$ is greater than zero, one simulation cycle is performed
with $\sigma$ as the starting state. At the beginning of the cycle,
the value of the input ports of the design under simulation are
updated with the values yielded by the simulation environment $E_p$ at
clock count $\tau$. Given a simulation environment
$E_p\in\mathbb{N}\rightarrow(id\nrightarrow{}v)$, the \texttt{inj}
function that update of the value of signals at a given design state
$\sigma\in\Sigma$ and clock cycle count $\tau\in{}\mathbb{N}$ is
defined as follows:
$\mathtt{inj}(\sigma,E_p,\tau)=(\mathcal{S}_i,\mathcal{C})$ where
$\sigma=(\mathcal{S},\mathcal{C}), $ and $\mathcal{S}_i(x)=
\begin{cases}
  E_p(\tau)(x) & \mathrm{if}~x\in\mathtt{dom}(E_p(\tau)) \\
  \mathcal{S}(x) & \mathrm{otherwise}
\end{cases}$.

After the update of the input ports, the following sequence performs
the different phases of a clock cycle. First, all rising blocks
defined in the behavior of the design under simulation are
executed. The rising blocks correspond to the part of the design
behavior that are sensitive to the rising edge event of the clock
signal. % Remember that a \hvhdl{} design represents a synchronous
% design, meaning that its execution is synchronized with a clock
% signal.
The $\uparrow$ flag is appended to the evaluation relation for
concurrent statements to execute rising blocks. Then, follows a
stabilization phase that produces a stable state $\sigma'$. After
that, the falling blocks are executed in response to the occurrence of
the falling edge event of the clock signal. To the execution of the
falling blocks also follows a stabilization phase that produces a
stable state $\sigma''$.  Then, the \hvhdl{} simulation relation calls
itself recursively with a decremented cycle count and state $\sigma''$
as the starting state. The recursive call yields a trace $\theta$
which is appended to the states $\sigma'$ and $\sigma''$ to form the
final simulation trace. Note that we preserve in the simulation trace
only stable states, i.e. states at half a clock cycle and states at
the end of a clock cycle.

Table~\ref{tab:full-sim} presents the relation that formalizes our
entire simulation algorithm by appealing to the elaboration relation
(that do not present in this article, but which content is detailled
here\cite{Iampietro2021}), and to the simulation relation presented in
Table~\ref{tab:sim-loop}. The full simulation relation states that the
simulation of a design $d$ during $\tau$ clock cycles yields the trace
$(\sigma_0::\theta)$ in the context of the design store
$\mathcal{D}\in{}id\nrightarrow{}design$, the dimensioning function
$\mathcal{M}_g\in{}id\nrightarrow{}v$ (used for the elaboration of
design $d$), and under the simulation environment
$E_p\in\mathbb{N}\rightarrow(id\nrightarrow{}v)$. Here $\sigma_0$
represents the initial state of the design. The initial is computed
through an initialization phase consisting of the execution of the
first part of reset blocks (the $i$ flag is on) followed by a
stabilization phase. The execution of reset blocks corresponds to the
virtual activation of a reset signal at the beginning of the
simulation. This reset signal triggers the execution of certain part
of the behavior responsible for the initialization of the value of
chosen signals, which are all associated to an implicit default value
otherwise\footnote{In the default state, i.e. the state yielded after
  the elaboration of a design, all signals have are associated to the
  implicit default value of their type in the signal store. }. Then,
the simulation trace $\theta$ is the result of the simulation of
design $d$ during $\tau$ clock cycles with $\sigma_0$ as starting
state. As a side condition, we enforce the fact that, at every clock
count of the simulation, the definition domain of the simulation
environment is a subset of the input port identifiers. Otherwise, the
update of signal values happening at the beginning of a clock cycle
possibly the value of signals other than input ports.


\begin{table}[!h]

  \caption{Full simulation}
  \label{tab:full-sim}
  % {\fontsize{10}{13}\selectfont\textsc{FullSim}}
  
  \begin{prooftree}[template=\inserttext]

    % Design elab.
    \hypo{$\mathcal{D},\mathcal{M}_g\vdash{}d\xrightarrow{elab}\Delta,\sigma$}

    % Initialization.
    
    % Run all processes once.
    \hypo{$\mathcal{D},\Delta,\sigma\vdash{}d.beh\xrightarrow{cs_i}{}\sigma'$}

    % Stabilization phase after init.
    \infer[no rule]1{$\mathcal{D},\Delta,\sigma'\vdash{}d.beh\xrightarrow{\rightsquigarrow}{}\sigma_0$}
    
    % Simulation main loop.
    \infer[no rule]1{$\mathcal{D},E_p,\Delta,\tau,\sigma_0\vdash{}{}d.beh\rightarrow\theta$}
    
    \infer2 [$\forall\tau_i\in\mathbb{N},~\mathsf{dom}(E_p)(\tau_i)\subseteq{}\mathsf{dom}(I(\Delta))$] { $\mathcal{D},\mathcal{M}_g,E_p,\tau\vdash$
      ${}d\xrightarrow{full}(\sigma_0::\theta)$ }
  \end{prooftree}
\end{table}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
