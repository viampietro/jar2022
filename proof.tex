\section{Proof of semantic preservation}
\label{sec:proof}

The semantic preservation property of the HM2T is expressed by a
\textit{forward simulation} theorem, which general form is as follows
(according to \cite{Leroy2009}):
\begin{equation*}
  \forall{}S,C,B,\mathtt{transf}(S)=C\land{}S\Downarrow{}B\Rightarrow{}\exists{}B'~s.t.~C\Downarrow{}B'\land{}B\sim{}B'.
\end{equation*}

Considering the above theorem in a more general framework than the one
of compilers from programming languages (which is the framework of
\cite{Leroy2009}), $S$ corresponds to an instance of a source
formalism, and $C$ is the result of the transformation of $S$ by the
transformation function $\mathtt{transf}$; $C$ is an instance of a
target formalism. $B$ and $B'$ are behaviors, and the binary relation
$\Downarrow$ states that a given instance of a formalism has a given
behavior. $B\sim{}B'$ states that the behavior $B$ is similar to the
behavior $B'$ considering a contextual definition of the similarity
relation. The forward simulation theorem must be read as follows: for
all instance $S$ of a source formalism transformed into $C$ by
function $\mathtt{transf}$, if $S$ has a behavior $B$, then $C$ has a
behavior $B'$ that is similar to $B$. In our case, we have proved a
slightly different theorem, which has the following form:
\begin{equation*}
  \forall{}S,C,B,B',~\mathtt{transf}(S)=C\land{}S\Downarrow{}B\land{}C\Downarrow{}B'\Rightarrow{}B\sim{}B'.
\end{equation*}
In the above form, we consider that the target $C$ has the behavior
$B'$, and we no more have to prove the existence of such a behavior.
This version of the theorem focuses on the behavior similarity. Thus,
we refer to it has a behavior (or trace) similarity theorem. In our
work perspectives, we contrive to prove the first form of the theorem,
but in this article we will present the proof of the second form.

In our specific transformation case, $S$ is a SITPN model and $C$ is a
\hvhdl{} design. The behavior of a SITPN model and a \hvhdl{} design
corresponds to the execution trace computed through a certain number
of clock cycles w.r.t. semantics rules that have been presented in
Sections~\ref{subsec:hpn-particularities} and
\ref{subsec:sim-semantics}. Thus, the property of semantic
preservation for the HM2T is about comparing the execution traces of
the input SITPN model and the output \hvhdl{} design. Specifically, we
want to show that, no matter how much clock cycles are performed, the
execution traces are always
\textit{similar}. Figure~\ref{fig:trace-comparison} illustrates the
comparison of the execution traces of a SITPN model input of the HM2T
and its corresponding output design.
\begin{figure}[!ht]
  \centering
  \includegraphics[keepaspectratio,width=\textwidth]{trace-comparison-full.eps}
  \caption{Comparison between the execution trace of a SITPN model (on
    the upper part) and the execution trace of the \hvhdl{} design
    resulting from the HM2T (on the lower part). The $\uparrow$
    (resp. $\downarrow$) symbol represents a rising (resp. falling)
    edge step happening in the course of a clock cycle. The $\approx$
    symbol represents the similarity relation between the upper SITPN
    state and the lower \hvhdl{} design state.}
  \label{fig:trace-comparison}
\end{figure}

In Figure~\ref{fig:trace-comparison}, $\tau$ indicates an arbitrary
number of clock cycles. To perform the proof of semantic preservation,
we must prove that every pair of states considered at the same time
point are similar w.r.t. to our own similarity relation.  Let us
introduce our general similarity criterions between a SITPN state and
a \hvhdl{} state through the relation presented in
Definition~\ref{def:state-sim}.

\begin{definition}[State similarity relation]
  \label{def:state-sim}
  For a given $sitpn\in{}SITPN$, a \hvhdl{} design $d\in{}design$, and
  a binder $\gamma\in{}WM(sitpn,d)$, an SITPN state $s\in{}S(sitpn)$
  and a design state $\sigma\in\Sigma$ are similar, written
  $\gamma\vdash{}s\approx\sigma$ if
  \begin{enumerate}
  \item\label{item:sim-mark} $\forall{}p\in{}P,$
    $~s.M(p)=\sigma(\gamma(p))($\texttt{s\_marking}$)$.
  \item\label{item:sim-tc}
    $\forall{}t\in{}T_i,$\\
    $\big(u(I_s(t))=\infty\land{}s.I(t)\le{}l(I_s(t))\Rightarrow{}s.I(t)=\sigma(\gamma(t))($\texttt{s\_time\_counter}$)\big)$\\
    $\land\big(u(I_s(t))=\infty\land{}s.I(t)>{}l(I_s(t))\Rightarrow{}\sigma(\gamma(t))($\texttt{s\_time\_counter}$)=l(I_s(t))\big)$\\
    $\land\big(u(I_s(t))\neq\infty\land{}s.I(t)>{}u(I_s(t))\Rightarrow{}\sigma(\gamma(t))($\texttt{s\_time\_counter}$)=u(I_s(t))\big)$\\
    $\land\big(u(I_s(t))\neq\infty\land{}s.I(t)\le{}u(I_s(t))\Rightarrow{}s.I(t)=\sigma(\gamma(t))($\texttt{s\_time\_counter}$)\big)$.
  \item\label{item:sim-reset} $\forall{}t\in{}T_i,$
    $s.reset_t(t)=\sigma(\gamma(t))($\texttt{s\_reinit\_time\_counter}$)$.
  \item\label{item:sim-cond}
    $\forall{}c\in\mathcal{C},~s.cond(c)=\sigma(\gamma(c))$.
  \item\label{item:sim-act}
    $\forall{}a\in\mathcal{A},~s.ex(a)=\sigma(\gamma(a))$.
  \item\label{item:sim-fun}
    $\forall{}f\in\mathcal{F},~s.ex(f)=\sigma(\gamma(f))$.
  \end{enumerate}
\end{definition}

In Definition~\ref{def:state-sim}, the binder structure $\gamma$ that
is generated by the HM2T relates the elements of the SITPN model to
the elements of the \hvhdl{} design, and thus enables the comparison
between the SITPN state and the design state. In
Definition~\ref{def:state-sim}, Point~\ref{item:sim-mark} relates the
marking value of a place $p$ at state $s$ to the value of the
\texttt{s\_marking} signal, which is an internal signal of the PDI
identified by $\gamma(p)$. Here, the expression $\sigma(\gamma(p))$
returns the internal state of the PDI $\gamma(p)$ by looking up the
component store of state $\sigma$. Point~\ref{item:sim-tc} (resp.
Point~\ref{item:sim-reset} similarly relate the value of time counters
(resp. reset orders) of transitions to the value of the
$\texttt{s\_time\_counter}$ signal
(resp. $\texttt{s\_reinit\_time\_counter}$) in the internal state of
the corresponding TDIs. In Point~\ref{item:sim-cond}
(resp. \ref{item:sim-act} and \ref{item:sim-fun}), the Boolean value
of conditions (resp. actions and functions) are compared to the value
of the input (resp. output) ports of the output design, also based on
the $\gamma$ binder.  As one can observe in Point~\ref{item:sim-tc},
due to the specific implementation of time intervals with an infinite
upper bound in \hvhdl{}, the relation between the value of a time
counter and the value of the $\texttt{s\_time\_counter}$ signal can
not be restricted to a simple equality.

As shown in Figure~\ref{fig:trace-comparison}, we make a distinction
between the state similarity after a rising edge phase and after a
falling edge phase. The definitions of the post rising edge similarity
relation, written $\stackrel{\uparrow}{\approx}$, and the post falling
edge similarity relation, written $\stackrel{\uparrow}{\approx}$, are
restrictions of the general definition. After a rising edge phase, the
equality between the value of conditions and the value of condition
ports (i.e. Point~\ref{item:sim-cond} of
Definition~\ref{def:state-sim}) does not hold, and after a falling
edge phase, the equality between the value of time counter reset
orders and the value of the \texttt{s\_reinit\_time\_counter} signals
(i.e. Point~\ref{item:sim-reset} of Definition~\ref{def:state-sim})
does not hold. However, these divergences do not impact the
computation logic of the overall so that to create further behavioral
divergences between the input SITPN model and the output \hvhdl{}
design.

Definition~\ref{def:exec-trace-sim} introduces the relation that
states that a SITPN model's execution trace is similar to a \hvhdl{}
design's execution trace.

\begin{definition}[Execution trace similarity]
  \label{def:exec-trace-sim}
  For a given $sitpn\in{}SITPN$, a \hvhdl{} design $d\in{}design$, and
  a binder $\gamma\in{}WM(sitpn,d)$, the execution trace
  $\theta_s\in{}\mathtt{list}(S(sitpn))$ and the simulation trace
  $\theta_\sigma\in\mathtt{list}(\Sigma)$ are similar, written
  $\gamma\vdash{}\theta_s\stackrel{clk}{\sim}\theta_\sigma$ where
  $clk\in\{\uparrow,\downarrow\}$, according to the following rules:\\

  \begin{tabular}{@{}l}
    {\begin{prooftree}[template={\inserttext}]        
        \infer0[$clk\in{}\{\uparrow,\downarrow\}$]{$\gamma\vdash{}[~]\stackrel{clk}{\sim}{}[~]$}
      \end{prooftree}} 
  \end{tabular}
  \begin{tabular}{@{}l}
    {\begin{prooftree}[template={\inserttext}]

        \hypo{$\gamma\vdash{}s\stackrel{\uparrow}{\sim}\sigma$}
        \hypo{$\gamma\vdash{}\theta_s\stackrel{\downarrow}{\sim}{}\theta_\sigma$}
        \infer2{$\gamma\vdash{}(s :: \theta_s)\stackrel{\uparrow}{\sim}{}(\sigma :: \theta_\sigma)$}
      \end{prooftree}} 
  \end{tabular}
  \begin{tabular}{@{}l}
    {\begin{prooftree}[template={\inserttext}]

        \hypo{$\gamma\vdash{}s\stackrel{\downarrow}{\sim}\sigma$}
        \hypo{$\gamma\vdash{}\theta_s\stackrel{\uparrow}{\sim}{}\theta_\sigma$}
        \infer2{$\gamma\vdash{}(s :: \theta_s)\stackrel{\downarrow}{\sim}{}(\sigma :: \theta_\sigma)$}
      \end{prooftree}} 
  \end{tabular}
\end{definition}

In Definition~\ref{def:exec-trace-sim}, the clock event symbol on top
of the $\sim$ sign indicates the kind of clock event that led to the
production of the states at the head of the traces. The execution
trace similarity relation expects that the states composing the traces
have been alternatively produced by a rising edge step followed by a
falling edge step. By construction, the traces must have the same
length to respect the execution trace similarity relation.

To handle the case of an execution/simulation trace beginning by an
initial state, that is, a state neither reached after a rising nor
after a falling edge, we give a slightly different definition of the
execution trace similarity relation in
Definition~\ref{def:full-exec-trace-sim}.

\begin{definition}[Full execution trace similarity]
  \label{def:full-exec-trace-sim} For a given $sitpn\in{}SITPN$, a
  \hvhdl{} design $d\in{}design$, and a binder
  $\gamma\in{}WM(sitpn,d)$, the execution trace
  $\theta_s\in{}\mathtt{list}(S(sitpn))$ and the simulation trace
  $\theta_\sigma\in\mathtt{list}(\Sigma)$ are fully similar, written
  $\gamma\vdash{}\theta_s\sim\theta_\sigma$, according to the
  following rules:\\

  \begin{tabular}{l}
    {\begin{prooftree}[template={\inserttext}]
        \infer0{$\gamma\vdash{}[~]\sim{}[~]$}
      \end{prooftree}}
  \end{tabular}
  \begin{tabular}{l}
    {\begin{prooftree}[template={\inserttext}]

        \hypo{$\gamma\vdash{}s\sim\sigma$}
        \hypo{$\gamma\vdash{}\theta_s\stackrel{\uparrow}{\sim}{}\theta_\sigma$}
        \infer2{$\gamma\vdash{}(s :: \theta_s)\sim{}(\sigma ::
          \theta_\sigma)$}
      \end{prooftree}}
  \end{tabular}
\end{definition}

The full execution trace similarity relation indicates that the head
states of traces must verify the general state similarity relation
(cf. Figure~\ref{fig:trace-comparison}), and that the tail of the
traces must respect the execution state similarity relation starting
with a rising edge step.

Now, let us introduce the necessary lemmas to prove the semantic
preservation theorem. In Definition~\ref{def:hm2t-hyps}, we present
the hypotheses expressing the fact that we are proving the semantic
preservation property for the HM2T. These hypotheses will always
appear in the lemmas and theorems presented afterwards.

\begin{definition}[HM2T hypotheses]
  \label{def:hm2t-hyps}
  For all well-defined $sitpn\in{}SITPN$, bounding function
  $b\in{}P\rightarrow\mathbb{N}$, \hvhdl{} design $d\in{}design$,
  binder $\gamma\in{}WM(sitpn,d)$, elaborated design
  $\Delta\in{}ElDesign$, default state $\sigma_e\in\Sigma$, simulation
  environment $E_p\in\mathbb{N}\rightarrow{}(id\nrightarrow{}v)$, and
  execution environment
  $E_c\in\mathbb{N}\rightarrow(\mathcal{C}\rightarrow\mathbb{B})$,
  assume that:
  \begin{enumerate}
  \item\label{it:HM2T-some} Taking the SITPN model $sitpn$ and the
    bounding function $b$ as inputs, the HM2T returns an output design
    $d$ and a binder $\gamma$, written
    $\mathtt{sitpn2hvhdl}(sitpn, b)=\lfloor(d,\gamma)\rfloor$ where
    $\mathtt{sitpn2hvhdl}\in{}SITPN\rightarrow(P\rightarrow\mathbb{N})\nrightarrow(design\times{}WM(sitpn,d))$.
  \item\label{it:sitpn-is-bounded} $sitpn$ is bounded through $b$,
    written $\lceil{}sitpn\rceil^b$.
  \item In the context of the \hilecop{} design store
    $\mathcal{D}_\mathcal{H}$ and with an empty generic constant
    dimensioning function ($\emptyset$), $d$ is elaborated into
    $\Delta$ with a default state $\sigma_e$, written
    $\mathcal{D}_\mathcal{H},\emptyset\vdash{}d\xrightarrow{elab}\Delta,\sigma_e$.
  \item\label{it:env-are-sim} Simulation and execution environments
    are similar, written $\gamma\vdash{}E_p\stackrel{env}{=}E_c$.
  \end{enumerate}
  
\end{definition}

In Point~\ref{it:HM2T-some} of Definition~\ref{def:hm2t-hyps}, the
$\mathtt{sitpn2hvhdl}$ function implements the HM2T, that is a
function proved sound and complete w.r.t. to the specification
presented in Section~\ref{sec:m2t}. Point~\ref{it:sitpn-is-bounded}
expresses the boundedness property of the input SITPN
model. Point~\ref{it:env-are-sim} states that, at each time point, the
execution and simulation environments yield the same Boolean value for
all couple condition-condition port linked through $\gamma$.

\def\hm2thyps{well-defined $sitpn\in{}SITPN$,
  $b\in{}P\rightarrow\mathbb{N}$, $d\in{}design$,
  $\gamma\in{}WM(sitpn,d)$, $\Delta\in{}ElDesign,\sigma_{e}\in\Sigma$,
  $E_p\in\mathbb{N}\rightarrow{}(id\nrightarrow{}v)$, and
  $E_c\in\mathbb{N}\rightarrow(\mathcal{C}\rightarrow\mathbb{B})$ that
  verify the hypotheses of Definition~\ref{def:hm2t-hyps}}

As illustrated in Figure~\ref{fig:trace-comparison}, to prove that the
execution traces are similar, we must first prove that the two initial
states are similar. This is expressed by
Lemma~\ref{lem:sim-init-states}.
\begin{lemma}[Similar initial states]
  \label{lem:sim-init-states}
  For all \hm2thyps{}, and for all $\sigma_0,\sigma_i\in{}\Sigma$ such that:
  \begin{itemize}
  \item $\sigma_0$ is the initial state of design $d$:\\
    $\mathcal{D},\Delta,\sigma_e\vdash{}d.beh\xrightarrow{cs_i}{}\sigma_i$ and
    $\mathcal{D},\Delta,\sigma_i\vdash{}d.beh\xrightarrow{\rightsquigarrow}{}\sigma_0$
  \end{itemize}
  then $\gamma\vdash{}s_0\approx\sigma_0$.
\end{lemma}

Starting from two similar initial states, then we must prove that each
phase, or step, of a clock cycle produces still similar states.  This
is expressed by \textit{lock-step simulation} lemmas \cite{Leroy2009},
which are of the following form in their \textit{non-existantial}
version:
\begin{equation*}
  \forall{}S_1,S'_1,S_2,S'_2,~S1\rightarrow{}S'_1\land{}S_2\rightarrow{}S'_2\land{}S_1\approx{}S_2\Rightarrow{}S'_1\approx{}S'_2.
\end{equation*}
Here, $S_1$ and $S'_1$ are two states of the source formalism, $S_2$
and $S'_2$ are two states of the target formalism.
$S_1\rightarrow{}S'_1$ (resp. $S_2\rightarrow{}S'_2$) states that an
execution step leads from $S_1$ to $S'_1$ (resp. from $S_2$ to $S'_2$)
w.r.t. a contextual definition of the execution
step. $S_1\approx{}S_2$ indicates that $S_1$ and $S_2$ are similar,
also w.r.t. a contextual definition of state similarity. The above
theorem must be read as follows: given two similar states $S_1$ and
$S_2$, if one execution step leads from $S_1$ to $S'_1$ and from $S_2$
to $S'_2$, then $S'_1$ and $S'_2$ are similar. \\

To establish the semantic preservation property, the first lock-step
simulation lemma that we had to prove pertains to the first rising
edge step. As defined in the SITPN semantics, the first rising edge
step is idle, i.e. a SITPN model is still in its initial state after
this step. Thus, we must prove that the state of the output design
reached after the first rising edge is similar to the SITPN model's
initial state. This is expressed by Lemma~\ref{lem:fst-re-lock-step}.

\begin{lemma}[First rising edge lock-step simulation]
  \label{lem:fst-re-lock-step}
  For all \hm2thyps{}, and for all clock count $\tau\in\mathbb{N}$,
  $\sigma_0,\sigma_i,\sigma_{\uparrow},\sigma'_0\in{}\Sigma$ such that:
  \begin{itemize}
  \item $\sigma_0$ is the initial state of design $d$:\\
    $\mathcal{D},\Delta,\sigma_e\vdash{}d.beh\xrightarrow{cs_i}{}\sigma_i$ and
    $\mathcal{D},\Delta,\sigma_i\vdash{}d.beh\xrightarrow{\rightsquigarrow}{}\sigma_0$
    
  \item a rising edge step leads from $\sigma_0$ to $\sigma'_0$:\\
    $\mathcal{D}_\mathcal{H},\Delta,\mathtt{inj}(\sigma_0,E_p,\tau)\vdash{}d.beh\xrightarrow{cs_{\uparrow}}\sigma_{\uparrow}$
    and
    $\mathcal{D}_\mathcal{H},\Delta,\sigma_{\uparrow}\vdash{}d.beh\xrightarrow{\rightsquigarrow}\sigma'_0$
  \end{itemize}
  then $\gamma\vdash{}s_0\stackrel{\uparrow}{\approx}\sigma'_0$.
\end{lemma}
In Lemma~\ref{lem:fst-re-lock-step}, $s_0$ is the initial state of the
SITPN model as introduced in
Definition~\ref{def:sitpn-init-state}.  Note that a rising edge step on the \hvhdl{} side refers to the conjunction of the three following phases: the injection of fresh values in primary input ports (through the use of the \texttt{inj} function), the execution of rising blocks, and the stabilization of combinational parts. \\

Then, we must prove that any rising edge or falling edge step verifies
the lock-step simulation property. This is expressed by
Lemmas~\ref{lem:re-lock-step} and \ref{lem:fe-lock-step}. 

\begin{lemma}[Rising edge lock-step simulation]
  \label{lem:re-lock-step}
  For all \hm2thyps{}, and for all $\tau\in\mathbb{N}$,
  $s,s'\in{}S(sitpn)$, $\sigma,\sigma_\uparrow,\sigma'\in\Sigma$, such
  that
  \begin{itemize}
  \item $s$ and $\sigma$ are similar states as intended after a
    falling edge step:
    $\gamma\vdash{}s\stackrel{\downarrow}{\approx}\sigma$
  \item a rising edge step leads from $s$ to $s'$:
    $E_c,\tau\vdash{}s\xrightarrow{\uparrow}s'$
  \item a rising edge step leads from $\sigma$ to $\sigma'$:\\
    $\mathcal{D}_\mathcal{H},\Delta,\mathtt{inj}(\sigma,E_p,\tau)\vdash{}d.beh\xrightarrow{cs_{\uparrow}}\sigma_{\uparrow}$
    and
    $\mathcal{D}_\mathcal{H},\Delta,\sigma_{\uparrow}\vdash{}d.beh\xrightarrow{\rightsquigarrow}\sigma'$
  \end{itemize}
  then $\gamma\vdash{}s'\stackrel{\uparrow}{\approx}{}\sigma'$.
  
\end{lemma}

\begin{lemma}[Falling edge lock-step simulation]
  \label{lem:fe-lock-step}
  For all \hm2thyps{}, and for all $\tau\in\mathbb{N}$,
  $s,s'\in{}S(sitpn)$, $\sigma,\sigma_\downarrow,\sigma'\in\Sigma$,
  such that
  \begin{itemize}
  \item $s$ and $\sigma$ are similar states as intended after a rising
    edge step: $\gamma\vdash{}s\stackrel{\downarrow}{\approx}\sigma$
  \item a falling edge step leads from $s$ to $s'$:
    $E_c,\tau\vdash{}s\xrightarrow{\downarrow}s'$
  \item a falling edge step leads from $\sigma$ to $\sigma'$:\\
    $\mathcal{D}_\mathcal{H},\Delta,\sigma\vdash{}d.beh\xrightarrow{cs_{\downarrow}}\sigma_{\downarrow}$
    and
    $\mathcal{D}_\mathcal{H},\Delta,\sigma_{\downarrow}\vdash{}d.beh\xrightarrow{\rightsquigarrow}\sigma'$
  \end{itemize}
  then $\gamma\vdash{}s'\stackrel{\downarrow}{\approx}{}\sigma'$.
\end{lemma}

As expressed in Lemma~\ref{lem:fe-lock-step}, a falling edge step on
the \hvhdl{} side refers to the execution of falling blocks followed
by the stabilization of combinational parts.\\

Under the assumptions of Lemma~\ref{lem:sim-init-states},
\ref{lem:fst-re-lock-step}, \ref{lem:re-lock-step} and
\ref{lem:fe-lock-step}, we can now prove the following trace
similarity theorem expressing that the HM2T is semantic preserving.

\begin{theorem}[Full trace similarity]
  \label{thm:full-trace-sim}
  For all well-defined $sitpn\in{}SITPN$, bounding function
  $b\in{}P\rightarrow\mathbb{N}$, \hvhdl{} design $d\in{}design$,
  binder $\gamma\in{}WM(sitpn,d)$, default state $\sigma_e\in\Sigma$,
  simulation environment
  $E_p\in\mathbb{N}\rightarrow{}(id\nrightarrow{}v)$, execution
  environment
  $E_c\in\mathbb{N}\rightarrow(\mathcal{C}\rightarrow\mathbb{B})$,
  $\tau\in\mathbb{N}$, SITPN model trace
  $\theta_s\in\mathtt{list}(S(sitpn))$, and \hvhdl{} design trace
  $\theta_\sigma\in\mathtt{list}(\Sigma)$ such that:
  \begin{enumerate}
  \item $\mathtt{sitpn2hvhdl}(sitpn, b)=\lfloor(d,\gamma)\rfloor$
  \item $\lceil{}sitpn\rceil^b$
  \item $\gamma\vdash{}E_p\stackrel{env}{=}E_c$
  \item $E_c,\tau\vdash{}sitpn\xrightarrow{full}\theta_s$
  \item
    $\mathcal{D}_\mathcal{H},\emptyset,E_p,\tau\vdash{}d\xrightarrow{full}\theta_\sigma$
  \end{enumerate}
  then $\gamma\vdash\theta_s\sim\theta_\sigma$.
\end{theorem}

\begin{pf}[Proof of Theorem~\ref{thm:full-trace-sim}.]
  
  Proceeding by case analysis on the number of clock cycles $\tau$,
  there are two cases. First $\tau=0$, and then we must prove that the
  initial states are similar, which is true appealing to
  Lemma~\ref{lem:sim-init-states}. Otherwise, $\tau>0$ and then at
  least the first clock cycle is executed. Thanks to
  Lemmas~\ref{lem:fst-re-lock-step} and \ref{lem:fe-lock-step}, we can
  show that the states are similar during the first clock cycle. Then,
  we can reason by induction over $\tau$ to prove that the remnant of
  the execution traces are similar. We can appeal to
  Lemmas~\ref{lem:re-lock-step} and \ref{lem:fe-lock-step} to prove
  that states are similar during the induction step (corresponding to
  an arbitrary clock cycle step), and then use the induction
  hypothesis to complete the proof.

\end{pf}

\subsection{A mechanization-ready proof}
\label{sec:mecha-ready-pf}

As presented above, proving Theorem~\ref{thm:full-trace-sim} amounts
to proving Lemma~\ref{lem:sim-init-states}, which is about the
similarity of the initial states, and the different lock-step
simulation lemmas (i.e. Lemmas~\ref{lem:fst-re-lock-step},
\ref{lem:re-lock-step} and \ref{lem:fe-lock-step}). Preparing for the
mechanization of the proof of Theorem~\ref{thm:full-trace-sim} with
the \coq{} proof assistant, we have written a very detailed proof (a
hundred-page long) for Lemmas~\ref{lem:sim-init-states},
\ref{lem:fst-re-lock-step}, \ref{lem:re-lock-step} and
\ref{lem:fe-lock-step}. The full proof is available in
\cite{Iampietro2021}. Even though obviously a tedious task, writing
the fully detailed proof before the mechanization has been a
successful process. It has revealed a bug in the \vhdl{} code defining
the behavior of the place design. This bug has been corrected in the
version of the place design given in Appendix~\ref{app:place-design}.
Due to the important amount of work demanded by the mechanization
task, if we had tackled down the mechanization of the proof without a
previously
detailed proof plan, this bug would not have yet been detected. \\

To illustrate the level of details of our proof, let us present an
extract of the proof of
Lemma~\ref{lem:re-lock-step}. Lemma~\ref{lem:re-lock-step} states that
the rising edge step verifies the lock-step simulation property. To
prove that the states of the input SITPN model and the output design
are similar after a rising edge step, we must prove, among other
points, that the marking of a given place is equal to the value the
\texttt{s\_marking} internal signal in its corresponding PDI. This is
expressed by Lemma~\ref{lem:re-eq-marking}.

\begin{lemma}[Rising edge equal marking]
  \label{lem:re-eq-marking}
  For all \hm2thyps{}, and for all $\tau\in\mathbb{N}$,
  $s,s'\in{}S(sitpn)$, $\sigma,\sigma_\uparrow,\sigma'\in\Sigma$, such
  that
  \begin{itemize}
  \item $s$ and $\sigma$ are similar states as intended after a
    falling edge step:
    $\gamma\vdash{}s\stackrel{\downarrow}{\approx}\sigma$
  \item a rising edge step leads from $s$ to $s'$:
    $E_c,\tau\vdash{}s\xrightarrow{\uparrow}s'$
  \item a rising edge step leads from $\sigma$ to $\sigma'$:\\
    $\mathcal{D}_\mathcal{H},\Delta,\mathtt{inj}(\sigma,E_p,\tau)\vdash{}d.beh\xrightarrow{cs_{\uparrow}}\sigma_{\uparrow}$
    and
    $\mathcal{D}_\mathcal{H},\Delta,\sigma_{\uparrow}\vdash{}d.beh\xrightarrow{\rightsquigarrow}\sigma'$
  \end{itemize}
  then
  $\forall{}p\in{}P,~s'.M(p)=\sigma'(\gamma(p))(\mathtt{s\_marking})$.
  
\end{lemma}

\begin{pf}[Proof of Lemma~\ref{lem:re-eq-marking}.]
  Given all the elements and assuming all the hypotheses expressed in
  Lemma~\ref{lem:re-eq-marking}, then, given a place $p\in{}P$, let us
  show that:
  \begin{equation*}
    \boxed{s'.M(p)=\sigma'(\gamma(p))(\texttt{s\_marking})}
  \end{equation*}

  By definition of the SITPN state transition relation on rising edge
  (cf. Definition~\ref{def:semantics}, Point~\ref{it:new-marking}), we
  have:
  \begin{equation}\label{eq:re-eq-marking-eqmp}
    s'.M(p)=s.M(p)-\sum\limits_{t\in{}Fired(s)}pre(p,t)+\sum\limits_{t\in{}Fired(s)}post(t,p)
  \end{equation}

  \bigskip
  
  By definition of the HM2T (cf. Definition~\ref{def:hm2t-spec},
  Point~\ref{it:pdi-exists}), there exists $g_p,i_p,o_p$ such that
  $\mathtt{comp}(\gamma(p),\mathtt{place},g_p,i_p,o_p)\in{}d.beh$.  By
  property of the \hvhdl{} concurrent statement execution relation
  (cf. Table~\ref{tab:cs-eval}), the stabilization relation
  (cf. Table~\ref{tab:stabilization}),
  $\mathtt{comp}(\gamma(p),\mathtt{place},g_p,i_p,o_p)\in{}d.beh$, and
  through the examination of the \texttt{marking} process defined in
  the behavior of the place design (Appendix~\ref{app:place-design},
  Line~49), we can deduce that the following equation holds:
  \begin{equation}\label{eq:re-eq-marking-eqsm}
    \begin{split}
      \sigma'(\gamma(p))(\texttt{sm})=\sigma(\gamma(p))(\texttt{sm})-\sigma(\gamma(p))(\texttt{s\_output\_token\_sum})\\
      +\sigma(\gamma(p))(\texttt{s\_input\_token\_sum})
    \end{split}
  \end{equation}

  \bigskip
  
  \noindent{}Rewriting the goal with \eqref{eq:re-eq-marking-eqmp} and
  \eqref{eq:re-eq-marking-eqsm}, we must show that:
  \begin{equation*}
    \boxed{
      \begin{array}{c}
      s.M(p)-\sum\limits_{t\in{}Fired(s)}pre(p,t)+\sum\limits_{t\in{}Fired(s)}post(t,p)\\
      = \\
      \sigma(\gamma(p))(\texttt{sm})-\sigma(\gamma(p))(\texttt{sots})
      +\sigma(\gamma(p))(\texttt{sits}) \\
      \end{array}}
  \end{equation*}
  
  \bigskip
  
  By definition of the state similarity relation
  (cf. Definition~\ref{def:state-sim}, Point~\ref{item:sim-mark}), we
  can deduce that $s.M(p)=\sigma(\gamma(p))(\texttt{sm})$. Then, two
  points remain to be shown to complete the proof:
  \begin{enumerate}
  \item $\sum\limits_{t\in{}Fired(s)}pre(p,t)=\sigma(\gamma(p))(\texttt{sots})$
  \item $\sum\limits_{t\in{}Fired(s)}post(t,p)=\sigma(\gamma(p))(\texttt{sits})$
  \end{enumerate}

  \bigskip
  
  We will only detail the proof of the second point. The \texttt{sits}
  signal is an internal signal of the place design. It is a
  \textit{combinational} signal, that is, an equation relates its
  value to the value of other signals, and this equation holds at any
  moment in the execution of the design.  In the case of the
  \texttt{sits} signal, the \texttt{input\_tokens\_sum} process
  defines the related combinational equation.  Thus, by property of
  the stabilization relation (cf. Table~\ref{tab:stabilization}),
  $\mathtt{comp}(\gamma(p),\mathtt{place},g_p,i_p,o_p)\in{}d.beh$, and
  through the examination of the \texttt{input\_tokens\_sum} process
  defined in the behavior of the place design
  (Appendix~\ref{app:place-design}, Line~29), we can deduce that the
  following equation holds:
  \begin{equation}
    \label{eq:sits-at-fe}
    \sigma(\gamma(p))(\texttt{sits})=\sum\limits_{i=0}^{\Delta(\gamma(p))(\texttt{ian})-1}
    \begin{cases}
      \sigma(\gamma(p))(\texttt{iaw})[i]~\mathtt{if}~\sigma(\gamma(p))(\texttt{itf})[i]\\
      0~otherwise \\
    \end{cases}
  \end{equation}

  \noindent{}Rewriting the goal with \eqref{eq:sits-at-fe}:\\
  \begin{equation*}
    \boxed{
      \sum\limits_{t\in{}Fired(s)}post(t,p)=\sum\limits_{i=0}^{\Delta(\gamma(p))(\texttt{ian})-1}
      \begin{cases}
        \sigma(\gamma(p))(\texttt{iaw})[i]~\mathtt{if}~\sigma(\gamma(p))(\texttt{otf})[i]\\
        0~otherwise \\
      \end{cases}}
  \end{equation*}

  \bigskip
  
  \noindent{}Let us unfold the definition of the left sum term:\\
  \begin{equation*}
    \boxed{\begin{array}{c}
      \sum\limits_{t\in{}Fired(s)}
      \begin{cases}
        \omega~\mathtt{if}~post(t,p)=\lfloor\omega\rfloor \\
        0~otherwise
      \end{cases} \\
      = \\
      \sum\limits_{i=0}^{\Delta(\gamma(p))(\texttt{ian})-1}
      \begin{cases}
        \sigma(\gamma(p))(\texttt{iaw})[i]~\mathtt{if}~\sigma(\gamma(p))(\texttt{itf})[i]\\
        0~otherwise \\
      \end{cases} \\
    \end{array}}
  \end{equation*}

  \bigskip
  
  \noindent{}Let us perform case analysis on $\mathtt{input}(p)$;
  there are two cases:

  \begin{itemize}
  \item \textbf{CASE} $\mathtt{input}(p)=\emptyset$:\\
    
    By definition of the HM2T (cf. \cite{Iampietro2022hfspec} to see
    the case where $\mathtt{input}(p)=\emptyset$), we have
    $(\mathtt{ian}\Rightarrow{}1)\in{}g_p$,
    $(\mathtt{itf}(0)\Rightarrow{}\mathtt{true})\in{}i_p$, and
    $(\mathtt{iaw}(0)\Rightarrow{}0)\in{}i_p$.

    By property of the elaboration relation, and knowing that
    $\mathtt{comp}(\gamma(p),\mathtt{place},g_p,i_p,o_p)\in{}d.beh$,
    $(\mathtt{ian}\Rightarrow{}1)\in{}g_p$,
    $(\mathtt{itf}(0)\Rightarrow{}\mathtt{true})\in{}i_p$, and
    $(\mathtt{iaw}(0)\Rightarrow{}0)\in{}i_p$, we can deduce that the
    following equations hold:
    \begin{eqnarray}
      \label{eq:eq-ian-itfz-iawz-0}
      \Delta(\gamma(p))(\texttt{ian})&=&1 \\
      \label{eq:eq-ian-itfz-iawz-1}\sigma(\gamma(p))(\texttt{itf})[0]&=&\mathtt{true} \\
      \label{eq:eq-ian-itfz-iawz-2}\sigma(\gamma(p))(\texttt{iaw})[0]&=&0
    \end{eqnarray}

    By property of $\mathtt{input}(p)=\emptyset$, we can deduce:
    \begin{equation}
      \sum\limits_{t\in{}Fired(s)}
      \begin{cases}
        \omega~\mathtt{if}~post(t,p)=\lfloor\omega\rfloor \\
        0~otherwise
      \end{cases}=0.
      \label{eq:post-sum-eq-z}    
    \end{equation}

    \noindent{}Rewriting the goal with \eqref{eq:eq-ian-itfz-iawz-0},
    \eqref{eq:eq-ian-itfz-iawz-1}, \eqref{eq:eq-ian-itfz-iawz-2} and
    \eqref{eq:post-sum-eq-z}, we arrive to a tautology.\\
    
  \item \textbf{CASE} $input(p)\neq\emptyset$:\\

    By definition of the HM2T (Definition~\ref{def:hm2t-spec},
    Point~\ref{it:pdi-gmap}), we have
    $(\mathtt{ian}\Rightarrow{}\vert{}input(p)\vert)\in{}g_p$, and by
    property of the elaboration relation, we can deduce:
    \begin{equation}
      \Delta(\gamma(p))(\texttt{ian})=\vert{}input(p)\vert\label{eq:ian-eq-input-card}
    \end{equation}

    To ease the reading, let us define functions
    $f\in{}Fired(s)\rightarrow\mathbb{N}$ and
    $g\in[0,\vert{}input(p)\vert-1]\rightarrow\mathbb{N}$ s.t. $f(t)=
    \begin{cases}
      \omega~\mathtt{if}~post(t,p)=\lfloor\omega\rfloor \\
      0~otherwise
    \end{cases}$
    and $g(i)=
    \begin{cases}
      \sigma(\gamma(p))(\texttt{iaw})[i]~\mathtt{if}~\sigma(\gamma(p))(\texttt{itf})[i]\\
      0~otherwise 
    \end{cases}$.

    \noindent{}The goal can be expressed as follows:
    \begin{equation*}
      \boxed{\sum\limits_{t\in{}Fired(s)}f(t)=\sum\limits_{i=0}^{\Delta(\gamma(p))(\texttt{ian})-1}g(i)}
    \end{equation*}
    
    \noindent{}Rewriting the goal with \eqref{eq:ian-eq-input-card}, we must show:
    \begin{equation*}
      \boxed{\sum\limits_{t\in{}Fired(s)}f(t)=\sum\limits_{i=0}^{\vert{}input(p)\vert-1}g(i)}
    \end{equation*}

    Now, we must prove the above equality between two sums. We had to
    prove a lot of such equalities during the entire proof. Thus, we
    came up with Theorem~\ref{thm:sums-equal} that presents a set of
    sufficient conditions to prove that two sums are equal.
    \todo[inline]{Mettre la preuve du theoreme en annexe?}
    
    \begin{theorem}[Equality between two sums]
      \label{thm:sums-equal}
      For all sets $X,Y,A,B$ such that $A\subseteq{}X$ and
      $Y\subseteq{}X$, and for all functions
      $f\in{}A\rightarrow\mathbb{N}$, $g\in{}B\rightarrow\mathbb{N}$,
      if there exists $\beta\in{}Y\rightarrow{}B$ such that:
      \begin{itemize}
      \item $\beta$ is a bijection
      \item $\forall{}a\in{}A\cap{}Y,~f(a)=g(\beta(a))$
      \item $\forall{}a\in{}A\setminus{}Y,~f(a)=0$
      \item $\forall{}b\in{}B,\beta^{-1}(b)\notin{}A\Rightarrow{}g(b)=0$
      \end{itemize}
      then $\sum\limits_{a\in{}A}f(a)=\sum\limits_{b\in{}B}g(b)$.
    \end{theorem}
    
    By property of the HM2T, there exists a bijection
    $\beta\in\mathtt{input}(p)\rightarrow{}[0,\vert{}input(p)\vert-1]$
    such that:
    \begin{equation}
      \label{eq:bij-input}
      \begin{aligned}[t]
        \forall{}t&\in{}T,g_t,i_t,o_t,g_p,i_p,o_p,\omega\in\mathbb{N}^{*}, \\
                  & post(t,p)=\lfloor\omega\rfloor\Rightarrow \\
                  & \tdiInBeh\Rightarrow \\
                  & \pdiInBeh\Rightarrow\\
                  &
                    \begin{aligned}[t]
                      & (\mathtt{iaw}(\beta(t))\Rightarrow\omega)\in{}i_p \\
                      & \begin{aligned}[t]
                          \land\exists{}id_s~&s.t.~(id_s,\mathtt{bool})\in{}d.sigs \\
                                             & \land(\mathtt{fired}\Rightarrow{}id_s)\in{}o_t\land(\mathtt{itf}(\beta(t))\Rightarrow{}id_s)\in{}i_p.\\
                        \end{aligned} \\
                    \end{aligned}
        \\
      \end{aligned}
    \end{equation}

    Let us take $\beta$ and appeal to Theorem~\ref{thm:sums-equal} to
    prove the goal. Then, it suffices to show that:
    \begin{enumerate}
    \item $\beta$ is a bijection
    \item $\forall{}t\in{}Fired(s)\setminus{}\mathtt{input}(p),~f(t)=0$
    \item $\forall{}t\in{}Fired(s)\cap{}\mathtt{input}(p),~f(t)=g(\beta(t))$
    \item
      $\forall{}i\in{}[0,\vert\mathtt{input}(p)\vert-1],\beta^{-1}(i)\notin{}Fired(s)\Rightarrow{}g(i)=0$
    \end{enumerate}

    \bigskip
    
    \begin{enumerate}
    \item By assumption, $\beta$ is a bijection.
    \item Given a $t\in{}Fired(s)\setminus{}\mathtt{input}(p)$, let us
      show $f(t)=0$, that is:
      \begin{equation*}
        \boxed{
          \begin{cases}
            \omega~\mathtt{if}~post(t,p)=\lfloor\omega\rfloor \\
            0~otherwise
          \end{cases}=0
        }
      \end{equation*}

      \noindent{}As $t\notin{}\mathtt{input}(p)$, then
      $post(t,p)=\emptyset$, and that settles the goal.
      
    \item Given a $t\in{}Fired(s)\cap\mathtt{input}(p)$, let us show
      $f(t)=g(\beta(t))$, that is:
      \begin{equation*}
        \boxed{\begin{array}{c}
          \begin{cases}
            \omega~\mathtt{if}~post(t,p)=\lfloor\omega\rfloor \\
            0~otherwise
          \end{cases} \\
          = \\
          \begin{cases}
            \sigma(\gamma(p))(\texttt{iaw})[\beta(t)]~\mathtt{if}~\sigma(\gamma(p))(\texttt{itf})[\beta(t)] \\
            0~otherwise \\
          \end{cases} \\         
        \end{array}}
      \end{equation*}


      \noindent{}By definition of $t\in{}\mathtt{input}(p)$, there
      exists a weight $\omega\in\mathbb{N}^{*}$ such that
      $post(t,p)=\lfloor\omega\rfloor$.  Thus, the goal can be
      rewritten as follows:     
      \begin{equation*}
        \boxed{\omega=
          \begin{cases}
            \sigma(\gamma(p))(\texttt{iaw})[\beta(t)]~\mathtt{if}~\sigma(\gamma(p))(\texttt{itf})[\beta(t)]~ \\
            0~otherwise \\
          \end{cases}}
      \end{equation*}

     By definition of the HM2T (Definition~\ref{def:hm2t-spec},
     Point~\ref{it:exists-tdi}), there exist $g_t,i_t,o_t$ such that
     $\mathtt{comp}(\gamma(t),\mathtt{transition}, g_t, i_t,
     o_t)\in{}d.beh$. 
     
     Then, from \eqref{eq:bij-input}, we can deduce
     $(\mathtt{iaw}(\beta(t))\Rightarrow{}\omega)\in{}i_p$, and by
     property of the stabilization relation, we can deduce
     $\sigma(\gamma(p))(\texttt{iaw})[\beta(t)]=\omega$. Thus, the goal
     can be rewritten as follows:
     \begin{equation*}
       \boxed{\omega=
       \begin{cases}
         \omega~\mathtt{if}~\sigma(\gamma(p))(\texttt{itf})[\beta(t)]~ \\
         0~otherwise \\
       \end{cases}}
     \end{equation*}
     
     From \eqref{eq:bij-input}, we can deduce that there exists an
     $id_s$ such that:
     \begin{itemize}
     \item $(id_s,\mathtt{bool})\in{}d.sigs$
     \item $(\mathtt{fired}\Rightarrow{}id_s)\in{}o_t$
     \item $(\mathtt{itf}(\beta(t))\Rightarrow{}id_s)\in{}i_p$
     \end{itemize}
     
     Let us take such an $id_s$. By property of the stabilization
     relation, and knowing that
     $(\mathtt{fired}\Rightarrow{}id_s)\in{}o_t$ and
     $(\mathtt{itf}(\beta(t))\Rightarrow{}id_s)\in{}i_p$, we can deduce
     $\sigma(\gamma(p))(\texttt{itf})[\beta(t)]=\sigma(id_s)=\sigma(\gamma(t))(\texttt{fired})$.

     \noindent{}Thus, the goal can be rewritten as follows:
     \begin{equation*}
       \boxed{       \omega=
         \begin{cases}
           \omega~\mathtt{if}~\sigma(\gamma(t))(\texttt{fired}) \\
           0~otherwise \\
         \end{cases}
       }
     \end{equation*}
   
     Now, to conclude the proof, let us assume that
     $\sigma(\gamma(t))(\texttt{fired})=\mathtt{true}$ iff
     $t\in{}Fired(s)$. This assumption comes from Lemma ``Falling edge
     equal fired'', which proof is detailed and illustrated in
     \cite[p.220]{Iampietro2021}. This lemma states that, at the end
     of a falling edge step, there is an equivalence between the set
     of fired transitions and the value of the \texttt{fired} output
     port of each TDI. Then, knowing that $t\in{}Fired(s)$ and that
     state $s$ results from the execution of a previous falling edge
     step, we can deduce
     $\sigma(\gamma(t))(\texttt{fired})=\mathtt{true}$ and then
     conclude the goal.
     
   \item Given an $i\in[0,\vert\mathtt{input}(p)\vert-1]$, and
     assuming that $\beta^{-1}(i)\notin{}Fired(s)$, let us show
     $g(i)=0$, that is:
     \begin{equation*}
       \boxed{
         \begin{cases}
           \sigma(\gamma(p))(\texttt{iaw})[i]~\mathtt{if}~\sigma(\gamma(p))(\texttt{itf})[i] \\
           0~otherwise \\
         \end{cases}=0
       }
     \end{equation*}

     Let us define $t_i=\beta^{-1}(i)$. To conclude the goal, it is sufficient to show that:
     \begin{equation*}
       \boxed{\sigma(\gamma(p))(\mathtt{itf})[i]=\mathtt{false}}
     \end{equation*}

     By definition of the HM2T, there exist
     $g_{t_i}, i_{t_i}, o_{t_i}$ such that
     $\mathtt{comp}(\gamma(t_i), \mathtt{transition}, g_{t_i},
     i_{t_i}, o_{t_i})\in{}d.beh$.

     From $t_i\in\mathtt{input}(p)$, we can deduce that there exists
     $\omega''\in\mathbb{N}^{*}$ such that
     $post(t_i, p)=\lfloor\omega''\rfloor$.

     From \eqref{eq:bij-input}, we can deduce that there exists an
     $id_{s_i}$ such that:
     \begin{itemize}
     \item $(id_{s_i},\mathtt{bool})\in{}d.sigs$
     \item $(\mathtt{fired}\Rightarrow{}id_{s_i})\in{}o_{t_i}$
     \item $(\mathtt{itf}(i)\Rightarrow{}id_{s_i})\in{}i_p$
     \end{itemize}

     Let us take such an $id_{s_i}$. By property of the stabilization
     relation, and knowing that
     $(\mathtt{fired}\Rightarrow{}id_{s_i})\in{}o_{t_i}$ and
     $(\mathtt{itf}(i)\Rightarrow{}id_{s_i})\in{}i_p$, we can deduce
     $\sigma(\gamma(p))(\texttt{itf})[i]=\sigma(id_{s_i})=\sigma(\gamma(t_i))(\texttt{fired})$.
     Thus, the goal can be rewritten as follows:
     \begin{equation*}
       \boxed{\sigma(\gamma(t_i))(\mathtt{fired})=\mathtt{false}}
     \end{equation*}

     From Lemma ``Falling edge not equal fired''
     \cite[p.351]{Iampietro2021} and knowing that
     $t_i\notin{}Fired(s)$, we can conclude the proof. Lemma ``Falling
     edge not equal fired'' states that, at the end of a falling edge
     step, for all transition that is not fired, then the value of the
     \texttt{fired} output port of the corresponding TDI is
     \texttt{false}.
   \end{enumerate}
 \end{itemize}
 
\end{pf}


\subsection{Mechanization with the \coq{} proof assistant}
\label{sec:mech-of-the-proof}

  % In this section, we give
% metrics to measure this gap. We point out some of the reasons that may
% explain the gap, and comment on some employed techniques to reduce the
% size of proof scripts. As a remainder, the full code including
% specifications and proof scripts is available at
% \url{https://github.com/viampietro/ver-hilecop}.

Listing~\ref{lst:coq-full-trace-sim-thm} presents the \coq{}
implementation of Theorem~\ref{thm:full-trace-sim} along with the
sequence of tactics constituting its proof.

\begin{lstlisting}[language=Coq,caption={\coq{} implementation of
Theorem~\ref{thm:full-trace-sim} and the mechanized version of its
proof.},label={lst:coq-full-trace-sim-thm},
framexleftmargin=1.5em,
xleftmargin=2em,
numbers=left,
numberstyle=\tiny\ttfamily,
basicstyle=\fontsize{9}{11}\selectfont,
frame=tb]
Theorem sitpn2hvhdl_full_trace_sim :
  forall $\tau$ sitpn $E_c$ $\theta_s$ d $E_p$ b $\theta_\sigma$ $\gamma$,

    (* sitpn is well-defined. *)
    IsWellDefined sitpn ->
    
    (* The HM2T takes sitpn and b as inputs and 
       yields the couple (d, $\gamma$) . *)
    sitpn2hvhdl sitpn b = (inl (d, $\gamma$)) ->

    (* Environments are similar. *)
    SimEnv sitpn $\gamma$ $E_c$ $E_p$ ->
    
    (* $\theta_s$ is the execution trace of sitpn after $\tau$ clock cycles. *)
    SitpnFullExec $E_c$ $\tau$ sitpn $\theta_s$ ->    
    
    (* $\theta_\sigma$ is the simulation trace of d after $\tau$ clock cycles. *)
    hfullsim $E_p$ $\tau$ d $\theta_\sigma$ ->
    
    (* ** Conclusion: traces are similar. ** *)
    SimTrace $\gamma$ $\theta_s$ $\theta_\sigma$.
Proof.
  (* Case analysis on $\tau$ *)
  destruct $\tau$; intros;
  match goal with
  | [ H0: SitpnFullExec _ _ _, H1: hfullsim _ _ _ _ |- _ ] =>
    inversion_clear H0; inversion_clear H1
  end;
  match goal with
  | [ H2: simloop _ _ _ _ _ _ _ |- _ ] =>
      inversion_clear H2
  end.

  (* CASE $\tau=0$, GOAL $\gamma\vdash{}s_0\approx\sigma_0$. 
     Solved with [sim_init_states] lemma. *)
  - constructor; eauto with hilecop.

  (* CASE $\tau>0$, GOAL $\gamma\vdash[s_0 :: s_0 :: s_1 :: \theta_s]\sim[\sigma_0 :: \sigma'_0 :: \sigma_1 :: \theta_\sigma]$.   
     Solved with [first_rising_edge], [falling_edge] 
     and [trace_sim] lemmas. *)
  - match goal with
    | [ H: simcycle _ _ _ _ _ _ _ _ |- _ ] =>
        inversion_clear H; repeat (constructor; eauto with hilecop)
    end.
Qed.
\end{lstlisting}

The proof script laid out in Listing~\ref{lst:coq-full-trace-sim-thm}
follows the structure of the paper proof of
Theorem~\ref{thm:full-trace-sim}. However, most part of the proof has
been abstracted away thanks to the use of the hint database mechanism
in conjunction with the \texttt{auto} and \texttt{eauto}
tactics\footnote{See
  \url{https://coq.inria.fr/refman/proofs/automatic-tactics/auto.html}
  for more information on programmable proof search using hint
  databases and the \texttt{auto} tactic.}.  This is representative of
our strategy to keep our mechanized proofs robust to change. To
achieve this, we follow the advices laid out in \cite{Chlipala2010}.

In the proof script of Listing~\ref{lst:coq-full-trace-sim-thm}, we
first perform case analysis on the clock cycle count $\tau$ by
appealing to the \texttt{destruct} tactic. This leads to the creation
of two proof sub-goals, one for $\tau=0$ and another for
$\tau>0$. Before solving each sub-goal individually, we prepare the
proof context by appealing to the \texttt{intros} tactic and then by
performing pattern matching and unfolding of definitions. The
\texttt{intros} tactic introduces all universally-bound variables and
hypotheses in the proof context. Then, the pattern matching of
Lines~25 to 32 in conjunction with the \texttt{inversion\_clear}
tactic unfolds the definition of the SITPN full execution relation
(resp. the \hvhdl{} full simulation relation and the \hvhdl{}
simulation loop relation) which is an implementation of Definition
(resp. Table~\ref{tab:full-sim} and Table~\ref{tab:sim-loop})\todo{Add
  ref to the SITPN full execution relation}.  Then, the
\texttt{constructor} tactic builds sub-goals to be proved based on the
definition of the full trace similarity relation,
i.e. \texttt{SimTrace}, which is an implementation of
Definition~\ref{def:full-exec-trace-sim}. We let the \texttt{eauto}
tactic decide which lemma apply to solve the sub-goals generated by
the \texttt{constructor} tactics. We give a hint to the \texttt{eauto}
tactic so that it looks in the user-defined \texttt{hilecop} database
of theorems and lemmas to solve the sub-goals. The \texttt{hilecop}
database contains the \coq{} implementation of all the theorems and
lemmas used to prove Theorem~\ref{thm:full-trace-sim}, namely: the
\texttt{sim\_init\_states} lemma which implements
Lemma~\ref{lem:sim-init-states}, the \texttt{first\_rising\_edge}
lemma which implements Lemma~\ref{lem:fst-re-lock-step}, the
\texttt{rising\_edge} lemma which implements
Lemma~\ref{lem:re-lock-step}, and the \texttt{falling\_edge} lemma
which implements Lemma~\ref{lem:fe-lock-step}.  The second part of the
proof, corresponding to the induction on $\tau$, is abstracted away in
an intermediary lemma called \texttt{sim\_trace}. The
\texttt{sim\_trace} lemma is automatically called by the
\texttt{eauto} tactic to complete the goal.

% \paragraph{Robustness to change}
% \label{sec:robustness}

% The proof laid out in Listing~\ref{lst:coq-full-trace-sim-thm} is
% representative of our strategy to keep our mechanized proofs robust to
% change. The robustness criterion is important for multiple reasons.
% First, in the proceeding of the proof, we can always realize that some
% case is missing in the expression of the transformation function or
% discover that the semantics of the SITPNs or the \hvhdl{} language is
% incomplete or incorrect. Therefore, we want to structure our proofs in
% a way that will lower the impact of correcting the transformation
% function or completing the semantics. Second, we know that the SITPN
% structure and the \hvhdl{} code of the place and transition designs
% will be evolving in the future. Therefore, we want to be able to adapt
% our proofs with a minimum effort. To reach robustness to change, we
% follow the indications laid out in \cite{Chlipala2010}. Mainly, we
% make an important use of the pattern matching constructs, such as
% \texttt{lazymatch} or \texttt{match}, to seek hypotheses in the
% current proof context. Also, we build hint databases and rely as much
% as possible on the use of the \texttt{auto} and \texttt{eauto} to
% solve the conclusions.

% \paragraph{Automation}

% To shorten the size of proofs, we develop user-defined tactics using
% the \coq{} \texttt{Ltac} language. The tactic that most contributed to
% the reduction of the size of the proof scripts is the \texttt{minv}
% tactic (see \texttt{StateAndErrorMonadTactics.v} under the
% \texttt{common} folder). The \texttt{minv} tactic automates the proof
% of certain lemmas regarding the properties of the \hilecop{}
% transformation function in the context of the state-and-error monad.
% Our \coq{} implementation of the \hilecop{} transformation function
% implements the state-and-error monad. This monad simulates imperative
% language traits into functional languages. All functions involved in
% the \hilecop{} transformation function carry a compile-time state,
% defined as the \coq{} type \texttt{CompileTimeState}. Each function
% either returns a value, modifies the compile-time state or does
% both. To give an example of the use of the \texttt{minv} tactic,
% Listing~\ref{lst:gen-p-comp-inst} shows the implementation of the
% \texttt{generate\_place\_comp\_inst} function involved in \hilecop{}
% transformation function. The \texttt{generate\_place\_comp\_inst}
% function generates a \hvhdl{} PCI statement from a place $p$ passed as
% a parameter. As a side effect, the
% \texttt{generate\_place\_comp\_inst} function adds the PCI statement
% to the behavior of the top-level design currently built in the
% compile-time state.

% \begin{lstlisting}[language=coq,caption={\coq{} implementation of the \texttt{generate\_place\_comp\_inst} function; the function takes an SITPN place $p$ as a parameter, and modifies the compile-time state without returning a value (i.e. the function return type is \texttt{unit})},label={lst:gen-p-comp-inst}]
% Definition generate_place_comp_inst (p : P sitpn) : CompileTimeState unit :=

%    do id         <- get_nextid;
%    do _          <- bind_place p id;
%    do pcomp      <- get_pcomp p;
%    do pcomp_inst <- HComponent_to_comp_inst id place_entid pcomp;
%    add_cs pcomp_inst.
% \end{lstlisting}

% In its definition body, function \texttt{generate\_place\_comp\_inst}
% sequentially calls to functions that sometimes modify the compile-time
% state (e.g. the \texttt{bind\_place} function adds a binding between
% $p$ and $id$ in the generated $\gamma$ binder, i.e. $\gamma(p)=id$
% after the call to \texttt{bind\_place}), or sometimes simply return a
% value without modifying the state (e.g. \texttt{get\_pcomp} returns an
% intermediate structure representing the place component instance
% associated to place $p$ in the compile-time state). During the
% mechanization of the proof, we often need to prove that some
% properties hold between the input compile-time state and the output
% compile-time after the call to a certain function. For example, after
% calling the \texttt{generate\_place\_comp\_inst} function on a given
% place $p$ and for a given input state $s$, let us say that a new
% compile-time state $s'$ is returned. We want to show that the part of
% the $\gamma$ binder pertaining to the binding of transitions to TCI
% identifiers has not changed between state $s$ and state
% $s'$\footnote{Remember that the $\gamma$ binder is part of the
%   compile-time state record type.}. To perform the proof, we need to
% show that each function call composing the sequence of the
% \texttt{generate\_place\_comp\_inst} function returns a compile-time
% state verifying the wanted property. Proving simple property like
% verifying that part of the compile-time states are equal through the
% multiple invocation of functions is highly automatable. We adapt the
% tactic \texttt{monadInv} defined in the \ccert{} project
% \cite{Leroy2009} to automate proof for such properties. The result is
% the tactic \texttt{minv} massively used in the proofs pertaining to
% state invariants\footnote{State invariance lemmas are to be found in
%   the \texttt{GenerateInfosInvs.v},
%   \texttt{GenerateArchitectureIns.v}, \texttt{GeneratePortsInvs.v} and
%   \texttt{GenerateHVhdlInvs.v} under the \texttt{sitpn2hvhdl} folder
%   of the Git repository.}.

\paragraph{On the difficulty of mechanizing the proof}

The work of mechanizing the proof of Theorem~\ref{thm:full-trace-sim}
is an ongoing task. To complete it, we have to mechanize the proofs of
Lemma~\ref{lem:sim-init-states}, \ref{lem:fst-re-lock-step},
\ref{lem:re-lock-step} and \ref{lem:fe-lock-step}. At the time of the
writing, we have only mechanized two points over the six that
constitute the proof of Lemma~\ref{lem:sim-init-states}. However, the
effort to achieve this little part of the overall verification amounts
to three months of work, and no more than lines of proof
script\todo{Add count of proof script lines.}.

\bigskip

First, we explain the difficulty of the mechanization, in comparison
with the verification works conducted for compiler for programming
languages, by the structure of our source
formalism.  % At the beginning
% of the project aiming at verifying that the HM2T is semantic
% preserving, we were inspired by the successful works conducted in
% the field of compiler verification. However, the main difference
% between the HM2T and compilers for programming languages (PLs) lies
% in the source formalism.
The structure of SITPNs greatly impacts the reasoning method,
especially for the proof of the lock-step lemmas. In the works
pertaining to the verification of compilers for PLs, the proof of a
lock-step lemma is tackled down by performing inductive reasoning over
the relation that computes one execution step for the source
program. This opens a proof sub-goal for each form of the source
program, thus following the structure of the abstract syntax of the
source langugae. Each simple form leads to the production of a simple
output, and this mechanism increases the straightforwardness of the
proof. In our case, performing inductive reasoning over the SITPN
state transition relation, that is the execution step relation, does
not lead to the decomposition of the source model into simpler
structures that would be transformed into simple output in terms of
\vhdl{} code. To summarize, we can not rely on the inductive structure
of the source formalism to cut down the difficulty of our proofs.

\bigskip

Second, even though our paper proof is very detailed
(cf. Section~\ref{sec:mecha-ready-pf}), there is still a huge gap
between the paper version and the computer-checked version written in
\coq{}.  Right now, the \coq{} proof wins the size competition. The
most significant distance between the size of the paper proof and the
machine-checked proof comes from the two following points:
\begin{enumerate}
  
\item Describing the content of the output design based on the
  input SITPN model and the \texttt{sitpn2hvhdl} function.
\item Describing the value of signals of the output design in the
  course of its execution.
\end{enumerate}

Regarding the first point, the \texttt{sitpn2hvhdl} is an \coq{}
implementation of the HM2T. Each time we are using the definition of
the HM2T to describe the content of the output design in our paper
proof, we must prove that the \texttt{sitpn2hvhdl} verifies this
property in \coq{}. For instance, Point~\ref{it:pdi-exists} of the
specification of the HM2T specifies that for each place of the input
SITPN model there must exists an PDI in the output design. This is
invoked as a one-line sentence in the
paper proof (cf. Section~\ref{sec:mecha-ready-pf}), namely:\\

\textit{By definition of the HM2T (cf. Definition~\ref{def:hm2t-spec},
  Point~\ref{it:pdi-exists}), there exists $g_p,i_p,o_p$ such that
  $\mathtt{comp}(\gamma(p),\mathtt{place},g_p,i_p,o_p)\in{}d.beh$.}

\bigskip

However, proving that the \texttt{sitpn2hvhdl} function verifies this
property in the mechanized version of the proof amounts to
approximately a thousand lines of proof script. As the
\texttt{sitpn2hvhdl} function is rather complex, finding the point in
the function where the property will appear and then propagating the
property through the remainder of the function calls is not an easy
task.  The \texttt{sitpn2hvhdl} function follows the state-and-error
monad, and we have done much to automatize the propagation of
properties through the numerous monadic calls\footnote{See the
  definition of the \texttt{solve\_sinv} tactic in the
  \texttt{transformation/proofs/SInvTactics.v} file, under our
  \textsf{Git} repository.}.

Now, let us look at the second point that explains the distance
between paper proof and machine-checked proof. Once we have done
describing the content of the output design, for instance, the
existence of a PDI in the output, there is always a need to establish
the value of signals at the current execution state. This is done by
reasoning over the relations defined in the simulation semantics of
the \hvhdl{} language. For instance, at the beginning of the extract
of proof laid out in Section~\ref{sec:mecha-ready-pf}, we describe the
value of the \texttt{sm} internal signal of PDI $\gamma(p)$ at state
$\sigma'$. We use the following sentence: \\

\textit{By property of the \hvhdl{} concurrent statement execution
  relation (cf. Table~\ref{tab:cs-eval}), the stabilization relation
  (cf. Table~\ref{tab:stabilization}),
  $\mathtt{comp}(\gamma(p),\mathtt{place},g_p,i_p,o_p)\in{}d.beh$, and
  through the examination of the \texttt{marking} process defined in
  the behavior of the place design (Appendix~\ref{app:place-design},
  Line~49), we can deduce that the following equation holds:}
\begin{equation*}
  \begin{split}
    \sigma'(\gamma(p))(\texttt{sm})=\sigma(\gamma(p))(\texttt{sm})-\sigma(\gamma(p))(\texttt{s\_output\_token\_sum})\\
    +\sigma(\gamma(p))(\texttt{s\_input\_token\_sum})
  \end{split}
\end{equation*}

Mechanizing the proof to obtain the above equation (or any such
equation) has a substantial cost in terms of lines of proof
script. First, we have to extract the value of the \texttt{sm} signal
by reasoning over the execution relation for sequential statement
applied to the body of \texttt{marking} process. Then, we have to
prove that, as the \texttt{sm} signal is a synchronous signal, the
stabilization phase does not modify its value; This among other
accessory but yet necessary lemmas to prove, such that the fact that
there is unique PDI $\gamma(p)$ in the behavior of the output design,
or the fact that the \texttt{marking} signal is the only one to assign
the \texttt{sm} signal, etc. In its machine-checked version, this
sentence amounts to approximately \todo{Determine number of lines}
lines of proof script.

% To give an example, we begin the proof of
% Lemma~\ref{lem:init-states-eq-marking} by taking a place $p$ and a PCI
% identifier $id_p$ linked through the $\gamma$ binder returned by the
% transformation function. Then, we state the existence of a PCI
% statement, identified by $id_p$ and with an associated generic map,
% input port map and output port map, in the behavior of the top-level
% design returned by the transformation function. To do so, we use the
% following the sentence:

% \begin{center}
%   ``Let us take a $p\in{}P$ and an $id_p\in{}Comps(\Delta)$ such that
%   $\gamma(p)=id_p$. By construction, there exist $g_p,i_p,o_p$
%   s.t. $\mathtt{comp}(id_p,\texttt{place},g_p,i_p,o_p)\in{}d.cs$.''
% \end{center}

% The expression ``by construction'' is a shorthand expression for
% ``knowing how the target \hvhdl{} design is constructed by the
% transformation function'', ``based on the definition of the
% transformation function'', or again ``by property of the
% transformation function''. In \coq{}, proving the lemma that states
% the existence of a PCI for a given place $p$ amounts to $1500$ lines
% of proof script. The lemmas regarding properties of PCI and TCI
% statements deduced from the transformation function tend to have
% complicated proofs. 

% We believe that the implementation of the \hilecop{} transformation
% function could be more straightforward in order to simplify this
% kind of proof. By straightforward, we mean that the number of steps
% separating a given place or a given transition from the generation
% of their corresponding PCI or TCI could be diminished, maybe at the
% cost of time performance. Right now, ease of proof is more important
% than time performance, considering that our goal is to prove the
% semantic preservation theorem in a reasonable amount of time.
% Still, the major complexity of the transformation function, i.e.
% what makes the proofs so hard, lies in the generation of the
% interconnections between PCIs and TCIs. Some engineering effort
% could be spent to simplify this particular part of the
% transformation.

% Also, we spent a lot of time proving some uninteresting, however
% necessary, properties about the \hvhdl{} design states and the
% \hvhdl{} simulation relations. For instance, we proved a lot of lemmas
% pertaining the preservation of identifiers through the simulation
% phases (e.g. if a signal identifier is present in a design state at
% the beginning of a stabilization phase, then it is still present at
% the end of the phase). We also proved a lot of uninteresting
% properties about the \hvhdl{} elaborated designs and the \hvhdl{}
% elaboration relation. For instance, properties on the uniqueness of
% identifiers in design states, in elaborated designs\dots We believe
% that a more systematic use of dependent types, especially to implement
% the \hvhdl{} design state and the elaborated design structure, could
% prevent us from proving this kind of lemmas.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
